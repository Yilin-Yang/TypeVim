*TypeVim.txt*	Object-oriented programming helpers and goodies for VimL.
Yilin Yang <yiliny@umich.edu>                              *TypeVim* *TypeVim*

==============================================================================
CONTENTS                                                    *TypeVim-contents*
  1. Introduction..............................................|TypeVim-intro|
  2. Summary.................................................|TypeVim-summary|
      1. Differences from Traditional OOP................|TypeVim-differences|
      2. Sugar.................................................|TypeVim-sugar|
      3. Type Information.......................................|TypeVim-type|
  3. Functions.............................................|TypeVim-functions|
  4. Dictionaries..............................................|TypeVim-dicts|
  5. Class Definitions..........................................|TypeVim-make|
      1. Declaring a Class................................|TypeVim-basic_decl|
      2. Declaring a Derived Class (Polymorphism)..........|TypeVim-poly_decl|
      3. Reserved Attributes................................|TypeVim-reserved|
  6. About.....................................................|TypeVim-about|

==============================================================================
INTRODUCTION                                                   *TypeVim-intro*

A library providing a prototype-based class system in VimL.

VimL allows users to assign Funcrefs into a dictionary; these |function|s, if
declared with the |dict| attribute, will be able to access and modify their
"owner" dictionary through a variable (`l:self`) accessible from within their
function body. This allows for object-oriented programming (OOP).

Unfortunately, VimL provides few of the "quality-of-life" features that make
OOP powerful. It lacks type safety, for instance, and lacks explicit support
for OOP features like polymorphism. Implementing these features in VimL is
possible, but involves a great deal of boilerplate.

TypeVim is meant to provide a sensible, standardized framework for "native"
object-oriented programming in VimL.

==============================================================================
SUMMARY                                                      *TypeVim-summary*

TypeVim is not a classical (no pun intended) "class-based" OOP system. TypeVim
is built using VimL's |Dictionary-function|s, which allows for "piecemeal"
construction of objects by assigning |Funcref|s, |Partial|s, and other
variables into |Dictionaries|.

==============================================================================
DIFFERENCES FROM TRADITIONAL OOP                         *TypeVim-differences*

"NATIVE" VIMSCRIPT CLASSES
VimL does not provide for explicit class declarations, like C++ or Java; it is
much more akin to the type system used in languages like JavaScript. To
declare a "class," one must declare a function ("constructor") that creates a
dict and assigns into it the class's member functions and variables: these
dicts are called *prototypes*. The constructor returns copies of these
prototypes as initialized "class instances."

"Native" (i.e. non-TypeVim) VimL Class instances will lack type information
(like the name of its class) unless assigned such information explicitly, and
nothing prevents the programmer from altering its interface at runtime: by
deleting member functions, altering them, redeclaring them, or adding new ones
entirely.  This allows for JavaScript-esque monkey-patching at runtime, but
can make it difficult to enforce type safety or preserve class invariants.

INHERITANCE
Inheritance, however, is concatenative; "derived classes" are just base class
prototypes with new (or overwritten) member functions and variables. VimL (as
far as I know) does not support behavior delegation, nor does it actually
support JavaScript-esque `[[Prototype]]` chains. An object has, at
construction, all of the class members that it will ever have, unless the user
decides to explicitly alter that object's members at runtime.

CLEAN-UPPERS
Prototype-based type systems, like JavaScript's, generally lack formal
C++-style destructors; the same is true of VimL, and TypeVim by extension. Vim
has its own |garbagecollect()|or that it uses for managing object lifetimes.
This eliminates the need for explicit C++-style memory management on the
programmer's end, but also prevents automatic, customizable RAII-style
destruction when a variable "leaves scope."

For this reason, TypeVim does not support user-declared destructors: instead,
it offers "clean-uppers." Like destructors, clean-uppers perform "end-of-life"
cleanup for an object (e.g. clearing |augroup|s and mappings), but unlike
destructors: (1) they must be called explicitly; and (2) they do not actually
destroy the object. Different clean-uppers can be declared at different points
in a class hierarchy: when calling a class instance's `CleanUp()` function,
those clean-uppers will be called in reverse order, going from the most
derived class up to the base class.

All valid TypeVim objects shall have a clean-upper, even if it does nothing.
This is largely handled by TypeVim itself: calls to |typevim#make#Class()| and
|typevim#make#Derived()| will automatically provide dummy clean-uppers if none
are provided.

==============================================================================
SUGAR                                                          *TypeVim-sugar*

TypeVim also provides additional "sugar" meant to make OOP easier. As of the
time of writing, this includes: pretty printers (like
|typevim#object#PrettyPrint()| and |typevim#object#ShallowPrint()|) for
printing objects in human-readable fashion; the object-oriented
|TypeVim.Buffer| wrapper object, including its version-agnostic functions for
editing the wrapped buffer "in the background"; and the |TypeVim.Promise|
datatype.

==============================================================================
TYPE INFORMATION                                                *TypeVim-type*

TypeVim objects are |dictionaries| annotated with a TYPE attribute. As of the
time of writing, this is a |list| containing all of the object's typenames,
ordered from the base class (at index zero) to the most derived class (at the
end of the list). This list should not be modified directly.

Declaring a class in TypeVim is done using helper functions:
|typevim#make#Class()| for base classes, and |typevim#make#Derived()| for
derived classes. The class's typename is a |string| that gets passed to these
functions in the class's constructor. See |TypeVim-make| for more details.

Users can check whether a TypeVim object is an instance of a particular type
using |typevim#value#IsType()|, or assert the same using
|typevim#ensure#IsType()|. Checking whether a given value is a TypeVim object
at all is done using |typevim#value#IsValidObject()|, or the analogous
function from the `ensure` namespace.

==============================================================================
FUNCTIONS                                                  *TypeVim-functions*

typevim#PrintShallow()                                *typevim#PrintShallow()*
  Wrapper around |typevim#object#ShallowPrint()|, provided because it's
  shorter and easier to type.

typevim#Print()                                              *typevim#Print()*
  Wrapper around |typevim#object#PrettyPrint()|, provided because it's shorter
  and easier to type.

typevim#Rethrow([v_exception])                             *typevim#Rethrow()*
  Read in the given [v_exception] and |:throw| it. If [v_exception] starts
  with "Vim", prepend a space to avoid "E608: Cannot :throw exceptions with
  'Vim' prefix" errors.

  Meant to be used when propagating a |v:exception| trapped by a "catch-all"
  |catch| statement.

  [v_exception] is |v:exception| if omitted.
  Throws ERROR(WrongType) if [v_exception] is not a string.

typevim#Any()                                                  *typevim#Any()*
  Return a numerical constant representing "any type". As of the time of
  writing, this is the numerical value returned by `type(v:null)` (see
  |type()|), but this may change in the future.

typevim#Bool()                                                *typevim#Bool()*
  Return the numerical value of |v:t_bool|.

typevim#Dict()                                                *typevim#Dict()*
  Return the numerical value of |v:t_dict|.

typevim#Float()                                              *typevim#Float()*
  Return the numerical value of |v:t_float|.

typevim#Func()                                                *typevim#Func()*
  Return the numerical value of |v:t_func|.

typevim#List()                                                *typevim#List()*
  Return the numerical value of |v:t_list|.

typevim#Number()                                            *typevim#Number()*
  Return the numerical value of |v:t_number|.

typevim#String()                                            *typevim#String()*
  Return the numerical value of |v:t_string|.

typevim#ensure#HasPartials()                    *typevim#ensure#HasPartials()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |Partial|s.

  Returns 1.

typevim#ensure#HasLambdas()                      *typevim#ensure#HasLambdas()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |lambda|s.

  Returns 1.

typevim#ensure#HasTypeConstants()          *typevim#ensure#HasTypeConstants()*
  Throws an ERROR(MissingFeature) if the current version of vim does not have
  |v:t_TYPE| constants.

  Returns 1.

typevim#ensure#HasSetBufline()                *typevim#ensure#HasSetBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |setbufline()|.

  Returns 1.

typevim#ensure#HasTimerTryCatchPatch()
                                      *typevim#ensure#HasTimerTryCatchPatch()*
  Throws an ERROR(MissingFeature) if the current version of vim will
  incorrectly terminate a timer if an exception occurs inside of a try-catch
  statement in the timer's callback function.

  Returns 1.

typevim#ensure#HasAppendBufline()          *typevim#ensure#HasAppendBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |appendbufline()|.

  Returns 1.

typevim#ensure#HasDeleteBufline()          *typevim#ensure#HasDeleteBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |deletebufline()|.

  Returns 1.

typevim#ensure#IsPositive({Val})                 *typevim#ensure#IsPositive()*
  Returns {Val} if it's positive. Else, throws ERROR(BadValue). Throws
  ERROR(WrongType) if {Val} is not a number.

typevim#ensure#IsNegative({Val})                 *typevim#ensure#IsNegative()*
  Returns {Val} if it's negative. Else, throws ERROR(BadValue). Throws
  ERROR(WrongType) if {Val} is not a number.

typevim#ensure#IsNonNegative({Val})           *typevim#ensure#IsNonNegative()*
  Returns {Val} if it's non-negative. Else, throws ERROR(BadValue). Throws
  ERROR(WrongType) if {Val} is not a number.

typevim#ensure#IsNonPositive({Val})           *typevim#ensure#IsNonPositive()*
  Returns {Val} if it's not positive. Else, throws ERROR(BadValue). Throws
  ERROR(WrongType) if {Val} is not a number.

typevim#ensure#IsGreaterThan({Val}, {Ref})    *typevim#ensure#IsGreaterThan()*
  Returns {Val} if it's greater than {Ref}. Else, throws ERROR(BadValue).
  Throws ERROR(WrongType) if {Val} or {Ref} are not numbers.

typevim#ensure#IsLessThan({Val}, {Ref})          *typevim#ensure#IsLessThan()*
  Returns {Val} if it's less than {Ref}. Else, throws ERROR(BadValue). Throws
  ERROR(WrongType) if {Val} or {Ref} are not numbers.

typevim#ensure#IsBool({Val})                         *typevim#ensure#IsBool()*
  Throws an ERROR(WrongType) if the given {Val} is not 1, 0, |v:true|, or
  |v:false|. Returns the given {Val} for convenience.

typevim#ensure#IsValidTypename({typename})  *typevim#ensure#IsValidTypename()*
  Throws an ERROR(BadValue) if the given {typename} is not a valid typename,
  along with the reason it's not a valid typename; otherwise, does nothing.

  Returns the given {typename} for convenience.

  Throws ERROR(WrongType) if the given {typename} is not a string.

typevim#ensure#IsValidIdentifier({id})    *typevim#ensure#IsValidIdentifier()*
  Throws an ERROR(BadValue) if the given {id} is not a valid identifier, along
  with the reason it's not a valid identifier; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsValidInterfaceProp({id})
                                       *typevim#ensure#IsValidInterfaceProp()*
  Throws an ERROR(BadValue) if the given {id} is not a valid interface
  property with a reason; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsTypeConstant({Val})         *typevim#ensure#IsTypeConstant()*
  Throws an ERROR(WrongType) if the given {Val} is not equal to a |v:t_TYPE|
  constant.

  Returns {Val} for convenience.

typevim#ensure#IsValidObject({Val})           *typevim#ensure#IsValidObject()*
  Throws an ERROR(WrongType) if the given {Val} is not a valid TypeVim object.

  Returns {Val} for convenience.

typevim#ensure#IsType({Obj}, {typename})             *typevim#ensure#IsType()*
  Throws an ERROR(WrongType) if the given {Obj} is not an instance of the type
  {typename}.

  Returns {Obj} for convenience.

  Throws ERROR(BadValue) if {Obj} is not a dict or {typename} is not a string.

typevim#ensure#Implements({Obj}, {Interface})    *typevim#ensure#Implements()*
  Throws an ERROR(WrongType) if the given {Obj} is not an implementation of
  {Interface}.

  Returns {Obj} for convenience.

  Throws ERROR(BadValue) if {Obj} is not a dict or {Interface} is not a
  TypeVim interface.

typevim#make#Class({typename}, {prototype}, [CleanUp])  *typevim#make#Class()*
  Return a "typevim-configured" instance of a class. Meant to be called from
  inside a type's constructor, where it will take a {prototype} dictionary
  (containing member functions and member variables), annotate it with type
  information, perform additional configuration (e.g. adding clean-uppers),
  and return it for convenience.

  {typename} is the name of the type being declared.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might not be implemented.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object, or 0. If [CleanUp] is 0, then the function will substitute a "dummy"
  clean-upper.

  [CleanUp] is 0 if omitted.
  Throws ERROR(BadValue) if the given {typename} is not a valid typename, see
  |typevim#value#IsValidTypename()|.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(NotAuthorized) if {prototype} defines attributes that should've
  been initialized by this function.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Derived({typename}, {Parent}, {prototype}, [CleanUp],
  [clobber_base_vars])                                *typevim#make#Derived()*
  Return a "prototypical" instance of a type that inherits from another. Meant
  to be called from inside a type's constructor.

  {typename} is the name of the derived type being declared.

  {Parent} is either a Funcref to the base class constructor, or a base class
  prototype. If arguments must be passed to said constructor, in the former
  case, this should be a Partial. If {Parent} is a prototype, then it will be
  left in an undefined state.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might be virtual. If the parent class
  defines functions with the same name (i.e. same dictionary key), they will
  be overridden with those of the {prototype}. The {prototype} dictionary
  given is modified after being passed in, and is returned from this function
  for convenience.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object, or 0. When invoked, defined clean-uppers will be called in reverse
  order, i.e. the "most derived" clean-upper will be called first, with the
  "original" base class clean-upper being called last. If [CleanUp] is 0, this
  function will substitute a "dummy" clean-upper.

  [clobber_base_vars] is a boolean flag that, if true, will allow member
  variables of the base class to be overwritten by member variables of the
  derived class being declared. This is discouraged, since direct access and
  modification of base class member variables is generally considered bad
  style.

  [CleanUp] is 0 if omitted.
  [clobber_base_vars] is 0 if omitted.

  Throws ERROR(BadValue) if {typename} is not a valid typename.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(NotAuthorized) when the given {prototype} would redeclare a
  non-Funcref member variable of the base class, and [clobber_base_vars] is
  not 1.
  Throws ERROR(WrongType) if arguments don't have the types named above, or if
  the base class {Parent} is not a valid TypeVim object.

typevim#make#Interface({typename}, {prototype})     *typevim#make#Interface()*
  Parse the given {prototype} into an immutable TypeVim interface object that
  can be used in calls to |typevim#value#Implements()| and similar functions.
  The given {prototype} is modified directly, and is returned for convenience.

  The returned object is a TypeVim object with the typename
  `"TypeVimInterface"`. It is made immutable using |lockvar|. It may be
  unlocked through a call to its `CleanUp()` function.

  {typename} is the human-readable name of the interface.

  The structure of {prototype} is similar to that of TypeScript interfaces:

  Each key is the name of a property, and should comply with the rules laid
  out by |typevim#value#IsValidInterfaceProp()|. These are essentially the
  same rules that define legal TypeScript interface properties, though
  arbitrary unicode characters are disallowed.

  The value associated with that key is called a property constraint, and may
  be a:
  Type constant, that is, a number indicating that property's type in valid
    implementations of the interface, i.e. one of the values of |v:t_TYPE| or
    the value returned by |typevim#Any(()|), or,
  Another TypeVim interface object, or,
  A valid TypeVim interface prototype (which will have the {typename}
    `"INTERFACE_ANON"`), or,
  A nonempty list of type constants and/or TypeVim interface objects and/or
    TypeVim interface prototypes, where each value corresponds to an allowable
    type, or,
  A nonempty list of strings ("tags"), where each string is an allowable value
    for the property (inferred to be of type |v:t_string|).

  When writing an interface {prototype}, one may specify: a built-in
  |v:t_TYPE| constant (e.g. |v:t_dict|, |v:t_func|); the literal number value
  of a |v:t_TYPE| constant (e.g. `1` for |v:t_string|), though this is not
  recommended since it lacks readability; or use TypeVim's helper functions
  (e.g. |typevim#Number()|), which return the same values as vim's built-in
  |v:t_TYPE|s. |typevim#Any(()|) may be used to indicate that any type is
  acceptable.

  The latter is version-agnostic and is recommended for compatibility reasons:
  the |v:t_TYPE| constants are not available in older versions of vim, where
  their use will throw |E121| "Undefined variable" exceptions. The presence of
  the |v:t_TYPE| constants can be checked using
  |typevim#value#HasTypeConstants()|.

  Throws ERROR(BadValue) if keys in {prototype} are not valid identifiers (the
  `"?"` character is valid at the end of these keys, however).
  Throws ERROR(WrongType) if {typename} is not a string, or {prototype} is not
  a dictionary, or if values in {prototype} are not |v:t_TYPE| values or a
  list of |v:t_TYPE| values or a list of strings


typevim#make#Extension({typename}, {base}, {prototype})
                                                    *typevim#make#Extension()*
  Return an interface, with the name {typename}, based on {prototype} that
  extends the given {base} interface. As with |typevim#makeInterface()|, the
  given {prototype} is modified directly and locked using |lockvar|.

  Any object that implements the interface made from {prototype} must
  necessarily implement the {base} interface, i.e. {prototype} cannot impose
  constraints that are incompatible with the {base} interface, such that an
  object cannot implement both interfaces at the same time.

  Throws ERROR(BadValue) if keys in {prototype} are not valid identifiers (the
  `"?"` character is valid at the end of these keys, however).
  Throws ERROR(NotAuthorized) if a property constraint in {prototype} is
  incompatible with a property constraint in {base}.
  Throws ERROR(WrongType) if {typename} is not a string, {base} is not a
  TypeVim interface, or if {prototype} does not satisfy the type checks in
  |typevim#make#Interface()|.

typevim#make#Instance({interface})                   *typevim#make#Instance()*
  Return a mutable object that is an implementation of the given {interface}.
  The returned object will be a "minimal" implementation, having no properties
  not originally found in {interface} (aside from standard TypeVim attributes,
  see |TypeVim-reserved|).

  The instance's typename will be the same as the typename of the interface.

  The value of each object property will be determined from its property
  constraint. If the property constraint is a single type constant:
  |v:t_bool| defaults to (the number) 0.
  |v:t_dict| defaults to `{}`, i.e. an empty dictionary.
  |v:t_float| defaults to `0.0`.
  |v:t_func| defaults to an arbitrary function that takes any number of
    arguments and returns 0.
  |v:t_list| defaults to `[]`, i.e. an empty list.
  |v:t_number| defaults to 0.
  |v:t_string| defaults to ''.
  |typevim#Any()| defaults to 0.

  If the property constraint is a tag list, the value defaults to the first
  tag in the list.

  If the property constraint is a TypeVim interface, the default value is a
  "default" implementation of that interface, as returned by, e.g. a recursive
  call to this function.

  If the property constraint is a list of type constants and/or TypeVim
  interfaces, the default value is populated from the first item in the list,
  e.g. the property:
>
    'someProperty': [v:t_float, v:t_number, g:some_interface]
<
  will default to `0.0`, because |v:t_float| is the first item in the list.

  Throws ERROR(BadValue) if {interface} is not a dict.
  Throws ERROR(WrongType) if {interface} is not a TypeVim interface.

typevim#make#Member({funcname}, [arglist], [dict])     *typevim#make#Member()*
  Return a |Funcref| to the function with the name constructed by
  concatenating the following: (1) the "autoload prefix" from which this
  function was called (e.g. if called from
  `~/.vim/bundle/myplugin/autoload/myplugin/foo.vim` the prefix would be
  "myplugin#foo#"); (2) the given {funcname}.

  If [arglist] or [dict] are provided, they are bound to the returned Funcref,
  turning it into a |Partial|. See |function()|.

  This is meant as a convenience function to reduce boilerplate when declaring
  TypeVim objects. Instead of long, explicit assignments like,
>
    " ~/.vim/bundle/myplugin/autoload
    function! myplugin#subdirectory#LongClassName#New() abort
      " ...
      let l:new = {
        " ...
        \ 'DoAThing':
            \ function('myplugin#subdirectory#LongClassName#DoAThing'),
      " ...
      return typevim#make#Class('LongClassName', l:new)
    endfunction

    function! myplugin#subdirectory#LongClassName#DoAThing() dict abort
      " ...
<

  One can instead write,
>
      " ...
      let l:new = {
        " ...
        \ 'DoAThing': typevim#make#Member('DoAThing'),
      " ...
<

  Which is functionally equivalent.

  [arglist] is [] if omitted.
  [dict] is nothing if omitted.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(WrongType) if {funcname} is not a string, or [arglist] is not a
  list, or [dict] is not a dictionary.

typevim#make#AbstractFunc({typename}, {funcname}, {parameters})
                                                 *typevim#make#AbstractFunc()*
  Returns a Partial, assignable into an object with type {typename}, standing
  in for a function named {funcname}, that takes in arguments with the names
  given in {parameters}.

  To specify optional parameters, enclose the parameter name in square
  brackets. To specify that a variable number of arguments are acceptable,
  write "...".

  Example invocation:
>
    let l:new['PureVirtualFunc'] = typevim#make#AbstractFunc(
          \ 'ExampleObject`, 'exampleMethod', '['arg1', '[optional1]', '...'])
<

  An argument list, if specified, must come after all other parameters named.
  Optional parameters, if specified, must come after all non-optional
  parameters, if any.

  Parameters names must be strings and cannot be empty strings, and must be
  valid identifiers (see |typevim#value#IsValidIdentifier()|). They must also
  be unique.

  The returned function, when invoked, will throw: ERROR(InvalidArguments) if
  given the wrong number of arguments (and if Vim itself doesn't throw an
  "|E116|: Invalid arguments for function" exception or an "|E119|: Not enough
  arguments for function" exception); or an ERROR(NotImplemented), if the
  given arguments are valid.

  If the number of arguments is correct, the returned function will throw an
  exception saying that it is an unimplemented virtual function
  Throws ERROR(BadValue) if {parameters} does not adhere to the requirements
  above; or if {typename} s not a valid typename.
  Throws ERROR(WrongType) if {typename} isn't a string or {parameters} isn't a
  list of strings.

typevim#object#Bind({Funcref}, {obj}, [arglist], [force_rebind])
                                                       *typevim#object#Bind()*
  Returns a Partial consisting of the given {Funcref} that is bound to this
  particular {obj} and to [arglist], i.e. return `function(a:Funcref,
  a:arglist, a:obj)`.

  If the member function is already bound to an arglist, then [arglist] will
  be appended to the function's current arglist.

  If the {Funcref} function is already bound to a dict, throws an
  ERROR(NotAuthorized) exception unless the dict and {obj} are the same
  object; however, if [force_rebind] is 1, the bound dict will be replaced
  with the given {obj}.

  This function is comparable to the `bind()` method on class member functions
  in JavaScript, and to the `std::bind()` function in the C++ standard
  library. Its primary purpose is to extract a "self-contained" class member
  Funcref that "remembers" its original `l:self`, even when it is assigned
  into another object. (This is done frequently in asynchronous event-based
  programming when passing callback functions.)

  See `:help Partial` for an explanation of why it would be bad not to do
  this. (In short, when a "non-bound" Funcref is assigned into another object,
  then when that object calls it, every `l:self` variable in the Funcref's
  definition will point to the NEW object, and NOT to the Funcref's original
  `l:self`; that invocation will then modify that new object as if it were the
  original `l:self`, even if it's of a different class entirely.)

  Note that argument parameters affect the RETURNED Funcref, NOT the Funcref
  that is given as an argument.
>
    " does NOT change obj.Method
    call typevim#object#Bind(obj.Method, diff_obj)

    " DOES change obj.Method
    let obj.Method = typevim#object#Bind(obj.Method, diff_obj)
<

  Throws ERROR(NotAuthorized) if {Funcref} is already bound to a dict that is
  not {obj} and [force_rebind] is 0.
  Throws ERROR(WrongType) if {obj} is not a dict, or if {Funcref} is not a
  Funcref, or if [arglist] is not a list.

typevim#object#GetIndentBlock({level})       *typevim#object#GetIndentBlock()*
  Return the string of spaces that would be used to indent a line to {level},
  assuming that indents are two-spaces wide. A {level} of 0 returns an empty
  string, while a {level} of 2 returns: `'    '`

  Throws ERROR(BadValue) if {level} is negative.
  Throws ERROR(WrongType) if {level} is not a number.

typevim#object#PrettyPrint({object})            *typevim#object#PrettyPrint()*
  Converts the given {object} into a string, suitable for error messages and
  debug logging.

  If it's already a string, encloses the string in quotes (useful when a
  string is purely whitespace). If it's a TypeVim object or a dictionary, adds
  newlines and tabs to make the resulting string human-readable.

  While the returned string can be |echo|ed to the screen as-is, it cannot be
  used directly in functions like |append()| or |Buffer.InsertLines()|, as
  these expect lists of strings where each list element is a single line. Use
  |typevim#string#Listify()| to convert this function's return value into such
  a list.

typevim#object#ShallowPrint({Obj}, [max_depth])
                                               *typevim#object#ShallowPrint()*
  Like |typevim#object#PrettyPrint()|, but will recurse at most [max_depth]
  levels down into {Obj} if it's a collection or a Partial.

  [max_depth] is 1 if omitted.
  Throws ERROR(BadValue) if [max_depth] is negative.
  Throws ERROR(WrongType) if [max_depth] is not a number.

typevim#string#Listify({string}, [fileformat])      *typevim#string#Listify()*
  Split the given {string} on newlines (or on carriage-returns and newlines)
  into a list of separate lines, usable in a call to a function like
  |append()| or |Buffer.InsertLines()|. Useful for formatting the output of
  |typevim#object#PrettyPrint()|.

  [fileformat] controls the line endings on which this function will split.
  Acceptable values include:

  "agnostic", which splits on an isolated <NL>, an isolated <CR>, the
    substring <CR><NL>, or the substring <NL><CR>,
  "unix", which splits only on <NL>,
  "dos", which splits on either an isolated <NL> OR the substring <CR><NL>,
  "mac", which splits only on <CR>,

  If this function does not split on a line ending character in {string} (e.g.
  if {string} contains a <CR>, but [fileformat] is "unix") then that character
  will be left unmodified in the returned list.

  If the string ends with a line ending character (e.g. {string} ends with an
  explicit <NL> and [fileformat] is "unix"), then the returned list will
  include an empty string at its end. If it ends with three such characters,
  then the returned list will include three empty strings, and so on.

  [fileformat] is "agnostic" if omitted.
  Throws ERROR(WrongType) if {string} is not a string.

typevim#string#IndentList({listified}, [indent_block])
                                                 *typevim#string#IndentList()*
  Prepend the given [indent_block] onto each line in {listified}, a list of
  strings usable in functions like |append()| and |Buffer.InsertLines()|.
  Returns the same list, for convenience.

  [indent_block] is "  " if omitted.
  Throws ERROR(WrongType) if {listified} is not a list of strings, or if
  [indent_block] is not a string.

typevim#value#HasPartials()                      *typevim#value#HasPartials()*
  Returns 1 if this version of vim supports |Partial| function references AND
  the ability to |get()| the components of a |Partial| or |Funcref| object,
  and 0 otherwise.

typevim#value#HasLambdas()                        *typevim#value#HasLambdas()*
  Returns 1 if this version of vim supports |lambda|s, and 0 otherwise.

typevim#value#HasTypeConstants()            *typevim#value#HasTypeConstants()*
  Returns 1 if this version of vim supports |v:t_TYPE| constants, and 0
  otherwise.

typevim#value#HasSetBufline()                  *typevim#value#HasSetBufline()*
  Returns 1 if this version of vim supports |setbufline|, and 0 otherwise.

typevim#value#HasTimerTryCatchPatch()  *typevim#value#HasTimerTryCatchPatch()*
  Returns 1 if this version of vim will, correctly, not terminate a timer if
  an exception occurs inside of a try-catch statement in the timer's callback
  function.

  If this is unsupported, |TypeVim.Promise| resolution and rejection are not
  guaranteed to work correctly.

typevim#value#HasAppendBufline()            *typevim#value#HasAppendBufline()*
  Returns 1 if this version of vim supports |appendbufline|, and 0 otherwise.

typevim#value#HasDeleteBufline()            *typevim#value#HasDeleteBufline()*
  Returns 1 if this version of vim supports |deletebufline|, and 0 otherwise.

typevim#value#IsBool({Val})                           *typevim#value#IsBool()*
  Returns 1 if the given {Val} is 1, 0, |v:true|, or |v:false|. Does not
  compare against |v:true| or |v:false| if those constants are not defined in
  the running version of vim.

  This function is provided for use in plugins that use the |v:true| and
  |v:false| constants, because |maktaba#value#IsBool()| will actually fail
  when given |v:true| or |v:false| as inputs: it only accepts a |v:t_number|
  equal to 0 or 1.

typevim#value#IsValidTypename({Typename})    *typevim#value#IsValidTypename()*
  Returns 1 when the given {Typename} is valid, 0 otherwise.

  A valid typename is a string of uppercase Latin letters, lowercase Latin
  letters, numbers, and underscores. It must start with a capital letter, and
  cannot contain "unusual" characters, e.g. accented Latin letters, emoji,
  etc.

  {Typename} cannot be an empty string, nor can it be a "reserved attribute".
  See |TypeVim-reserved| for more details.

typevim#value#IsValidIdentifier({Id})      *typevim#value#IsValidIdentifier()*
  Returns 1 when the given {Id} is a a valid identifier, 0 otherwise.

  A valid identifier must meet the same requirements as a valid typename (see
  |typevim#value#IsValidTypename()|), but can start with either a lowercase or
  uppercase letter.

typevim#value#IsValidInterfaceProp({Id})
                                        *typevim#value#IsValidInterfaceProp()*
  Returns 1 when the given {Id} is a a valid interface property, 0 otherwise.

  Valid interface properties must start with a letter (uppercase or
  lowercase), underscore, or dollar sign; the remaining characters may be
  letters (uppercase or lowercase), numbers, underscores, or dollar signs. The
  identifier may end with a question mark, to signifiy that the property is
  optional, though this question mark won't exist in "actual" interface
  implementations.

typevim#value#IsTypeConstant({Val})           *typevim#value#IsTypeConstant()*
  Returns 1 when the given {Val} is a number equal to a valid |v:t_TYPE|
  constant or |typevim#Any()|, and 0 otherwise.

typevim#value#IsValidObject({Val})             *typevim#value#IsValidObject()*
  Returns 1 when the given object is a valid TypeVim object, 0 otherwise.

  A valid TypeVim object is a dictionary. It shall contain the following
  attributes:
  A TYPE list: a list of strings containing the names of every class in the
    object's class hierarchy, with the original base class as the first
    element and the "most derived" class as the last.
  A CLEAN-UPPER: a member function, taking no arguments, that handles clean-up
    for the object. This function may do nothing: if, for instance,
    |typevim#make#Class()| is not given a clean-upper, the resulting object
    will be given a "dummy" clean-upper.

  See |TypeVim-reserved| for more details.

typevim#value#IsType({Obj}, {typename})               *typevim#value#IsType()*
  Returns 1 when the given {Obj} is an instance of the type {typename}, and 0
  otherwise.

  Throws ERROR(BadValue) if {typename} isn't a valid typename.
  Throws ERROR(WrongType) if {typename} isn't a string.

typevim#value#Implements({Obj}, {Interface})      *typevim#value#Implements()*
  Returns 1 when {Obj} is an implementation of {Interface}, and 0 otherwise.

  Throws ERROR(WrongType) if {Interface} is not a TypeVim interface (i.e. an
  object constructed through a call to |typevim#make#Interface()|.)

typevim#value#IsPartial({Obj})                     *typevim#value#IsPartial()*
  Returns 1 when the given object is a Partial (see `:help Partial`) and 0
  otherwise.

typevim#value#DecomposePartial({Func})      *typevim#value#DecomposePartial()*
  If the Funcref {Func} is a Partial, decomposes {Func} into a four-element
  list containing: first, the function name; second, the Funcref itself;
  third, the bound arguments; and fourth, the bound dictionary. The latter two
  elements can be empty if {Func} is not bound to arguments or a dictionary,
  respectively.

  Throws ERROR(WrongType) if {Func} is not a Funcref.

typevim#value#CompareKeys({lhs}, {rhs})          *typevim#value#CompareKeys()*
  Comparison function that only compares the zero-indexed element of two
  two-element lists, {lhs} and {rhs}. Can be used to sort the two-element
  lists returned by a call to |items()| based exclusively on keys, without
  considering the values associated with those keys. This is useful when
  getting "|E724|: Unable to dump object with self-referencing container"
  errors on calls like `sort(items(some_dict))`.

  Throws ERROR(BadValue) if {lhs} or {rhs} don't have length 2.
  Throws ERROR(WrongType) if {lhs} or {rhs} are not lists.

typevim#value#GetStackFrame({num_levels_down}) *typevim#value#GetStackFrame()*
  When invoked from a namespaced autoload function, return the name of the
  function {num_levels_down} the callstack, e.g. if called with
  {num_levels_down} = 2, get the callstack (as as string), strip this function
  from its top, then strip the function that called this function from its
  top, and then return the topmost function remaining

  Example inputs and outputs:
>
    function! Foo() abort
      " current callstack: function MainFunc[2]..<SNR>215_ScriptFunc[1]..Foo

      " echoes 'Foo', the name of the calling function
      echo typevim#value#GetStackFrame(0)

      " echoes '<SNR>215_ScriptFunc'
      echo typevim#value#GetStackFrame(1)

      " echoes 'MainFunc'
      echo typevim#value#GetStackFrame(2)

      " ERROR(NotFound)
      echo typevim#value#GetStackFrame(3)
    endfunction
<

  Throws ERROR(NotFound) if there is no stack frame {num_levels_down}.
  Throws ERROR(WrongType) if {num_levels_down} is not a number.

typevim#value#StackHeight()                      *typevim#value#StackHeight()*
  Returns the height of the callstack, not including the stack frame allocated
  for this function.

==============================================================================
DICTIONARIES                                                   *TypeVim-dicts*

                                                              *TypeVim.Buffer*
An encapsulation of a vim buffer; allows for manipulation of vim buffers as if
they were objects.

typevim#Buffer#New([properties])                                *Buffer.New()*
  Construct and return a new Buffer object. |TypeVim.Buffer| objects can
  either create their own |buffers| on construction, or be "given" a buffer by
  specifying the `fname` of an existing buffer through the `fname` property of
  [properties].

  [properties] is a dictionary whose keys and values are used to configure the
  new buffer. These include:

  `bufhidden`: A string. The buffer's |bufhidden| setting. Defaults to `hide`.
  `buflisted`: A boolean. The buffer's |buflisted| setting. Defaults to 0.
  `bufname`: A string. The name to be given to the buffer. If empty, the
    buffer will be given a name that is arbitrary, but unique.
  `bufnr`: A number. If empty or zero, then this |TypeVim.Buffer| will be
    initialized with a new vim buffer. This can be set to a nonzero value to
    give this |TypeVim.Buffer| ownership of an existing vim buffer with that
    |bufnr|. Defaults to 0.
  `buftype`: A string. The buffer's |buftype| setting. Defaults to `nofile`.
  `modifiable`: A boolean. Whether or not the user can edit the buffer. When
    true, the wrapped buffer is set to |nomodifiable|, but calls to functions
    like |Buffer.InsertLines()| will still be able to change the buffer's
    contents.
  `swapfile`: A boolean. The buffer's |swapfile| setting. Defaults to 0.

  All of these are optional and will have default values if not specified.
  Properties which are also vim settings can have any value that could be
  assigned to those settings explicitly, e.g. with `let &bufhidden = [...]`.

  If constructing a new buffer (i.e. `bufnr` is 0), then the given properties
  will be set on that buffer. If given an existing buffer (i.e. this
  |TypeVim.Buffer| is being given the buffer with |bufnr| 3, so `bufnr` is 3),
  then this function will try to set those properties on that buffer (e.g.
  change the buffer's |bufname|, change the buffer's |swapfile|). The latter
  may fail and throw an exception.

  [properties] is {} if omitted.
  Throws ERROR(BadValue) if the given `bufname` matches an existing buffer
  that isn't `bufnr` (when nonzero), this function will throw an
  ERROR(BadValue).
  Throws ERROR(WrongType) if the type of a value in [properties] doesn't match
  the list above.

Buffer.CleanUp()                                            *Buffer.CleanUp()*
  Perform cleanup for this Buffer object.

Buffer.ExchangeBufVars({vars_and_vals})             *Buffer.ExchangeBufVars()*
  For each buffer variable/setting and value in {vars_and_vals}:
  Replace the current value of "var" with "val",
  Save the previous value of "var", and,
  Return a dictionary of each modified variable, as well as its previous
    value.

  The returned dictionary may be provided to this function to restore the
  original values of each variable or setting. Note that, if a "var" did not
  previously exit before the first call to this function, then the second call
  will simply set the value of that "var" to an empty string: it will not
  |unlet| it.

  Throws ERROR(BadValue) if a "var" is an empty string, the string "&", or if
  it is an option that does not exist. No modification of the buffer will take
  place.
  Throws ERROR(WrongType) if {vars_and_vals} is not a dict.

Buffer.OpenDoRestore({Action})                        *Buffer.OpenDoRestore()*
  Silently perform the given {Action} with the buffer open and focused.

  Just like |typevim#Buffer#SetDoRestore()|, but instead of setting variables,
  this function opens the managed buffer in a new tab, performs the {Action},
  then closes that tab and returns to the previous view. This is done with
  |lazyredraw| enabled, and the previous view is restored even if executing
  {Action} results in an error.

  Throws ERROR(WrongType) if {Action} is not a Funcref or a string.

Buffer.SetDoRestore({temp_vars_and_vals}, {Action})    *Buffer.SetDoRestore()*
  Set the given {temp_vars_and_vals} through a call to
  |Buffer.ExchangeBufVars()|, call {Action}, and then restore the old values
  from before setting {temp_vars_and_vals}, even if invoking {Action} results
  in an exception being thrown.

  {Action} should be a Funcref (or a |Partial|) that can be invoked without
  this function supplying arguments, or a string that can be passed to an
  |:execute| statement.

  If {Action} is a Funcref, returns its return value. Else, returns 0.

  Throws ERROR(BadValue) if {Action} is a Funcref, but needs arguments.
  Throws ERROR(WrongType) if {temp_vars_and_vals} is not a dict, or if
  {Action} is not a Funcref.

  This function throws the same exceptions as |Buffer.ExchangeBufVars()|.

Buffer.getbufvar({varname}, [default])                    *Buffer.getbufvar()*
  Invoke `getbufvar` on this Buffer's stored buffer with the given arguments.
  See `:h getbufvar` for argument details.
  Throws ERROR(WrongType) if {varname} is not a string.

Buffer.setbufvar({varname}, {Val})                        *Buffer.setbufvar()*
  Invoke `setbufvar` on this Buffer's stored buffer with the given arguments.
  See `:h setbufvar` for argument details.
  Throws ERROR(WrongType) if {varname} is not a string.

Buffer.bufnr()                                                *Buffer.bufnr()*
  Returns the |bufnr| of the buffer owned by this |TypeVim.Buffer|.

  Throws ERROR(NotFound) if this |TypeVim.Buffer|'s buffer no longer exists.

Buffer.Open([cmd], [keepalt])                                  *Buffer.Open()*
  Open this buffer in the currently focused window.

  For details on [cmd], see `:h buffer`. [cmd] should include a leading `+`.
  If [keepalt] is 1, then the current alternate buffer will be preserved. See
  |keepalt|.

Buffer.Switch([open_in_any], [tabnr])                        *Buffer.Switch()*
  Move the cursor to (one of) this buffer's window(s) in the given tab.

  If [open_in_any] is 1, then it is "acceptable" for this function to switch
  to a window in a different tabpage if that window has this buffer open.

  Prefers to switch to a buffer in the current tabpage, or the tabpage with
  the given [tabnr] if possible. Does nothing if the current tabpage is
  "acceptable" and the current window has this buffer open.

  [open_in_any] is 0 if omitted.
  [tabnr] is the current tabpage if omitted.
  Throws ERROR(NotFound) if this buffer isn't open in the tab(s) specified.
  Throws ERROR(WrongType) if [open_in_any] is not a boolean, or if [tabnr] is
  not a number.

Buffer.SetBuffer({bufnr}, [action], [force])              *Buffer.SetBuffer()*
  Replace the buffer owned by this Buffer object with {bufnr}.

  [action] controls what happens to the buffer being replaced. It can be an
  empty string, `"bunload"`, `"bdelete"`, or `"bwipeout"`: these will do
  nothing, |bunload|, |bdelete|, or |bwipeout| the replaced buffer,
  respectively.

  If [force] is 1, unsaved changes in the replaced buffer will be ignored when
  unloading, deleting, or wiping the buffer out.

  Returns the |bufnr| of the replaced buffer.

  [action] is "" if omitted.
  [force] is 0 if omitted.
  Throws ERROR(BadValue) if [action] is not one of the values listed above.
  Throws ERROR(NotFound) if the given {bufnr} doesn't correspond to a real
  buffer.
  Throws ERROR(WrongType) if {bufnr} is not a number, if [action] is not a
  string, or if [force] is not a boolean.

Buffer.search({regexp}, [flags], [startpos], [stopline], [timeout],
  [ignore_badflags])                                         *Buffer.search()*
  Perform a |search()| in the given buffer and return the result.

  Finds a line number matching the given {regexp} and returns it. A string of
  additional [flags] may be provided to modify the behavior of the search,
  which starts from the given [startpos].

  This function is a wrapper around the |search()| function. The wrapped
  buffer is silently (with |lazyredraw| enabled) opened in a new tabpage,
  where the search is performed. Prior to the search, the cursor position is
  set to the given [startpos]. After the search, the previous cursor position
  is restored, the new tab is closed, and |lazyredraw| is reset to its
  previous value. This will have side effects; for instance, any applicable
  buffer events (e.g. |BufEnter|) will fire.

  The following [flags] are supported. Matching is always done as if the 'n'
  flag is set, and other flags that affect movement of the cursor are ignored.
  'b'   search Backward instead of forward
  'c'   accept a match at the Cursor position
  'p'   return number of matching sub-Pattern (see below)
  'w'   Wrap around the end of the file
  'W'   don't Wrap around the end of the file
  'z'   start searching at the cursor column instead of Zero

  Providing flags not in the above list will cause an ERROR(BadValue) to be
  thrown, unless [ignore_badflags] is set to 1, in which case, the "bad" flags
  are silently ignored. The 'n' flag, if provided, is always ignored.

  [startpos] may be a number or a list. If it's a number, the search will
  start from the start of that line. If it's a list, it must use one of the
  following structures:
  [ lineno, colno ]
  [ ..., lineno, colno, ... ]
  [ ..., lineno, colno, ..., ... ]

  lineno must be a positive number. colno must be non-negative. The latter two
  are provided so that a list returned by |getpos()| or |getcurpos()| may be
  used as a [startpos] value.

  [stopline] and [timeout] are used like in |search()|, albeit with stricter
  input validation. While |search()| will perform type coercion if necessary
  and possible, this function will reject values that aren't numbers. A value
  of zero is like not giving the argument.

  [flags] is "" if omitted.
  [startpos] is 1 if omitted.
  [stopline] is 0 if omitted.
  [timeout] is 0 if omitted.
  [ignore_badflags] is 0 if omitted.

  Throws ERROR(WrongType) if {regexp} is not a string, [flags] is not a
  string, [startpos] is not a number or a list, or [ignore_badflags] is not a
  bool.

  Throws ERROR(BadValue) if [flags] contains unsupported flags and
  [ignore_badflags] is 0, or if [startpos] is a list without 2, 4, or 5
  elements, or otherwise does not adhere to the requirements listed above, or
  if |setpos()| returns -1 when given (a "normalized") [startpos].

Buffer.OpenSplit({open_vertical}, [cmd], [pos], [size])   *Buffer.OpenSplit()*
  Open this buffer in a split.

  If {open_vertical} is 1, opens in a vertical split; if {open_vertical} is 0,
  opens in a horizontal split.

  For [cmd], see `:h +cmd`. It may be empty string, and should include a
  leading `"+"` character.

  [pos] is the part of the screen in which the split should be created. See
  `:h topleft` and `:h botright`. It may be the empty string.

  [size] is the height/width of the horizontal/vertical split to be created.
  If 0, this parameter will be ignored.

  [cmd] is "" if omitted.
  [pos] is "" if omitted.
  [size] is 0 if omitted.

  Throws ERROR(BadValue) if [pos] is not "leftabove", "aboveleft",
  "rightbelow", "belowright", "topleft", or "botright".
  Throws ERROR(WrongType) if {open_vertical} is not a boolean, if [cmd] is not
  a string, if [pos] is not a string, or if [size] is not a number.

Buffer.NumLines()                                          *Buffer.NumLines()*
  Return the total number of lines in this buffer.

Buffer.GetLines({startline}, [endline])                    *Buffer.GetLines()*
  Return lines {startline} to [endline], end-inclusive, from this buffer as a
  list of strings. Uses the same indexing rules as |Buffer.ReplaceLines()|.

  [endline] is {startline} if omitted.

Buffer.ReplaceLines({startline}, {endline}, {replacement})
                                                       *Buffer.ReplaceLines()*
  Change, add, or remove lines from this buffer, replacing lines {startline}
  through {endline}, end-inclusive, with the given {replacement}, a list of
  strings (one string per line).

  The number of lines in {replacement} can be does not need to be equal to
  `endline - startline + 1`, i.e. this function can replace part of a buffer
  with more lines than were originally there, or with fewer. For instance, if
  {replacement} is an empty list, the given line range will be deleted.

  Indexing is one-based: line 1 is the first line of the buffer. {startline}
  and {endline} can assume negative values; -1 is the last line of the buffer,
  -2 is the second-to-last line, and so on. 0 and `"$"` are not accepted
  values.

  This function still works even if the wrapped buffer is set as
  |nomodifiable|; it will set the buffer as |modifiable|, replace the given
  line range, and set the buffer back to |nomodifiable|.

  Throws ERROR(BadValue) if the {startline} is positioned after the {endline}
  in the buffer, or if the given lines are out of range for the current
  buffer, or if {startline} or {endline} are 0.
  Throws ERROR(WrongType) if {startline} or {endline} are not numbers, or if
  {replacement} is not a list of strings.

Buffer.InsertLines({after}, {lines})                    *Buffer.InsertLines()*
  Insert the given {lines} just below line {after}. Similar to
  |Buffer.ReplaceLines()|, except that it does not overwrite any of the lines
  in the buffer.

  This function uses the same indexing scheme |Buffer.ReplaceLines()|, with
  the following additions:

  {after} may be 0, which is the "line before-the-start" of the buffer. If
    {after} is 0, then the given {lines} will be prepended to the start of the
    buffer, i.e. above line 1.
  {after} may be `"$"`, which is the "line after-the-end" of the buffer. If
    {after} is `"$"`, then the given {lines} will be appended to the end of
    the buffer. (Note that you can also specify -1, or just explicitly specify
    the line number of the last line in the buffer.)

  This function still works even if the wrapped buffer is set as
  |nomodifiable|; it will set the buffer as |modifiable|, insert the given
  {lines}, and set the buffer back to |nomodifiable|.

  Throws ERROR(WrongType) if {after} is not a number or `"$"`, or if {lines}
  is not a list.

Buffer.DeleteLines({startline}, {endline})              *Buffer.DeleteLines()*
  Delete lines {startline} through {endline}, end-inclusive.

  This function still works even if the wrapped buffer is set as
  |nomodifiable|; it will set the buffer as |modifiable|, delete the given
  line range, and set the buffer back to |nomodifiable|.

  See |Buffer.ReplaceLines()| for details on exceptions and indexing.

Buffer.IsOpenInTab([tabnr])                             *Buffer.IsOpenInTab()*
  Returns 1 if this |TypeVim.Buffer| is open in the tabpage with the given
  [tabnr], and 0 otherwise. If the buffer owned by this |TypeVim.Buffer| no
  longer exists, return 0.

  [tabnr] is the current tabpage if omitted.
  Throws ERROR(BadValue) if [tabnr] is less than 1.
  Throws ERROR(WrongType) if [tabnr] is not a number.

                                                                *TypeVim.Doer*
A Doer that doesn't do anything, for use with |TypeVim.Promise|. Acts as an
interface, or as a base class for "real" Doer implementations.

In the future, TypeVim may provide Doer's that encapsulate the use of vim
channels and neovim job control.

Doer.New()                                                        *Doer.New()*
  Return a new Doer. Will start after a call to its virtual `StartDoing()`
  member function, which takes no arguments.

  Note that a Doer will not actually start running until a call to
  |Doer.SetCallbacks()|, to ensure that the job does not finish before a
  success (or error) handler has been attached.

Doer.SetCallbacks({Resolve}, {Reject})                   *Doer.SetCallbacks()*
  Set {Resolve} and {Reject} callbacks on this Doer, to be called when this
  Doer resolves or rejects after doing its assigned task.

                                                             *TypeVim.Promise*
A JavaScript-style Promise datatype for handling asynchronous operations.
|TypeVim.Promise| is meant to roughly mimic JavaScript Promise objects in
usage and interface, and is mostly compliant with the Promise/A+ spec.
Deviations from the spec are noted further below.

Because VimScript itself is entirely singlethreaded, Promise is only useful
when used with asynchronous operations, like asynchronous jobs and remote
procedure calls from neovim remote plugins.

PROMISE/A+ DIFFERENCES AND THINGS TO NOTE
These are listed by section, subsection, and clause, using the specification
on https://promisesaplus.com as reference.

2.2) |TypeVim.Promise| tries to adhere to the Google VimScript style guide,
  and names its member functions in UpperCamelCase, including
  |Promise.Then()|. `Promise.then()` is an alias of this function, since
  Promise/A+ requires that the `then` function be all lowercase.

2.2.4) |TypeVim.Promise| does not strictly guarantee that `then()` callbacks
  will be delayed until the callstack "contains only platform code." Whenever
  a Promise is resolved or rejected, it passes its attached callbacks to a
  zero-millisecond |timer| that won't fire until vim is idle, i.e. until the
  current function has returned, the callstack has cleared, and so on.
  However, if a function in that callstack |sleep|s, Promise timer callbacks
  may fire during that sleep interval.

2.3.1) When resolving a |TypeVim.Promise| with itself, Promise throws an
  ERROR(BadValue) instead of an ERROR(WrongType) (`"TypeError"`). This is for
  better consistency with vim-maktaba, since ERROR(BadValue) better describes
  the nature of the error.

2.3.3) |TypeVim.Promise| offers no special handling when resolved with objects
  that possess a `then` property, but which are not |TypeVim.Promise|s
  instances specifically. It will simply pass this object unmodified to its
  attached success handlers.

typevim#Promise#New([Doer])                                    *Promise.New()*
  Return a new Promise that will be fulfilled (or broken) by a given [Doer]
  object, if provided.

  The [Doer] will be initialized (through a call to its `SetCallbacks` method)
  with two Funcrefs: `Resolve` and `Reject`.

  The `Resolve` Funcref, when called by the [Doer], will fulfill ("resolve")
  this Promise with the passed value (e.g. `Resolve("foo")` will pass `"foo"`
  to all attached success handlers).

  The (optional) `Reject` Funcref, when called, will break ("reject") this
  Promise with the passed value (e.g. `Reject("foo")` will pass `"foo"` to all
  attached error handlers).

  `Reject` is optional in that the `Doer.SetCallbacks` function may take
  either one Funcref as an argument (`Resolve`), or two (`Resolve` and
  `Reject`). |TypeVim.Promise| detects this automatically:
>
    " (pseudocode, not actual implementation)
    function! typevim#Promise#NewDoer() abort
      " ...
      try
        Doer.SetCallbacks(self.Resolve, self.Reject)
      catch TooManyArguments
        Doer.SetCallbacks(self.Resolve)
      endtry
      " ...
<

  Note that, unlike JavaScript, [Doer] is an actual object, rather than a
  function. This is meant for convenience; [Doer] is likely to have other
  member functions that it will pass (as callback functions) to, e.g. neovim's
  |jobstart()| function.

  If no [Doer] is provided, then the Promise will only resolve or reject
  through explicit calls to |Promise.Resolve()| and |Promise.Reject()|.

  Throws ERROR(BadValue) if [Doer]'s `SetCallbacks` function does not take
  either one argument or two arguments, or if [Doer] has no `SetCallbacks`
  function.
  Throws ERROR(WrongType) if [Doer] is not an object, or if
  `Doer.SetCallbacks` is not a Funcref.

Promise.Resolve({Val})                                     *Promise.Resolve()*
  Fulfill ("resolve") this Promise. Calls back all attached success handlers
  with the given {Val}, and updates the |Promise.State()| of this Promise to
  `"fulfilled"`.

  If the given {Val} is, itself, a |TypeVim.Promise|, then this Promise will
  "follow" that Promise, i.e. if {Val} resolves, then this Promise will
  resolve with the same value; if {Val} rejects, then this Promise will reject
  with the same value. In either case, this Promise will not resolve
  immediately on this call. Note that this will "expunge" this Promise's
  current |TypeVim.Doer|, if it has one.

  Returns the given {Val}.

  Throws ERROR(BadValue) if the given {Val} is the same as this Promise.
  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.

Promise.Reject({Val})                                       *Promise.Reject()*
  Break ("reject") this Promise. Calls back all attached error handlers with
  the given {Val}, and updates the |Promise.State()| of this Promise to
  `"rejected"`.

  If this Promise has no "live" child Promises (i.e. no "next link" Promises
  with user-attached handlers), AND this Promise does not have any error
  handlers, throws an ERROR(NotFound) due to the unhandled exception.

  Note that, if a |TypeVim.Promise| is passed as {Val}, this function will not
  behave like |Promise.Resolve()|: it will not "wait" for {Val} to resolve or
  reject, but will start immediately calling back its error handlers with
  {Val} as its "reason".

  Returns the given {Val}.

  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.
  Throws ERROR(NotFound) if a valid error handler could not be found.

Promise.Then({Resolve}, [Reject], [chain])                    *Promise.Then()*
  Attach a success handler {Resolve} and optionally an error handler [Reject]
  to this Promise. If this Promise resolves, it will call back {Resolve} with
  the resolved value. If it rejects, it will call back [Reject], or throw an
  ERROR(NotFound) exception due to an unhandled rejection if there are no
  [Reject] error handlers "in the chain." (See |Promise.Reject()|.)

  If this Promise is already resolved, it will call {Resolve} immediately with
  the resolved value. If it was already rejected, it will call [Reject]
  immediately, or throw an ERROR(NotFound) exception.

  It is strongly suggested that a [Reject] handler be provided in calls to
  this function.

  If {Resolve} is not a Funcref, it will be replaced with a "default" Funcref
  that simply returns (unmodified) whatever value it's given. If [Reject] is
  not a Funcref, then the function will behave as if no error handler was
  given at all.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  value of the given {Resolve} success handler or [Reject] error handler
  respectively, unless [chain] is 0, in which case it will return 0.

  [Reject] is a "null" error handler. if omitted.
  [chain] is 1 if omitted.
  Throws ERROR(WrongType) if {Resolve} or [Reject] are not Funcrefs.

Promise.Catch({Reject}, [chain])                             *Promise.Catch()*
  Attach an error handler {Reject} to this Promise. If this Promise rejects,
  it will call back {Reject} with the provided value. If it was already
  rejected, it will call {Reject} immediately.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  given resolved value the return value of the {Reject} error handler
  respectively, unless [chain] is 0, in which case it returns 0.

  [chain] is 1 if omitted.

Promise.State()                                              *Promise.State()*
  Return the current state of this Promise: `"pending"`, `"fulfilled"`, or
  `"rejected"`.

Promise.Get()                                                  *Promise.Get()*
  Return the stored value/reason from this Promise's resolution/rejection.

  Throws ERROR(NotFound) if this Promise has not been resolved or rejected.

==============================================================================
CLASS DEFINITIONS                                               *TypeVim-make*

TypeVim offers helper functions for defining new object types. These are meant
to be invoked from within an object's constructor.

==============================================================================
DECLARING A CLASS                                         *TypeVim-basic_decl*

In general, to declare a new class, one should:

First, create a "namespaced" *.vim file for this class, i.e. a file in:
>
  myplugin/  # plugin root dir
    autoload/
      myplugin/  # autoload subdirectory; name matters
        ExampleClass.vim
<
Unless you have a good reason not to, all of `ExampleClass`'s relevant
functions should be declared in `ExampleClass.vim`. This has the benefit of
placing all of `ExampleClass`'s function definitions in an appropriate
"namespace". Based on vim's naming rules for autoload scripts (see `:help
autoload`), a function in `ExampleClass.vim` named `Foo()` will be invocable
through `:call myplugin#ExampleClass#Foo()`."

Second, declare a class constructor. By convention, a class constructor should
be named `New`, e.g. `myplugin#ExampleClass#New()`. It may have any number of
arguments.

Third, inside the constructor, construct a class "prototype." This is a
dictionary object initialized with your class's member variables and functions
(sometimes called "class properties," like in JavaScript):
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " type checking (with vim-maktaba) not required, but strongly encouraged
    call maktaba#ensure#IsNumber(a:num1)
    call maktaba#ensure#IsString(a:str2)

    " optional parameter with a default value of 3.14
    let l:optional_float = maktaba#ensure#IsFloat(get(a:000, 0, 3.14))

    let l:example_prototype = {
        \ '_single_underscore': a:num1,
        \ '_implies_var_is_private': a:str2,
        \ '__double_underscore': l:optional_float,
        \ '__means_definitely_private': 42,
        \ 'PublicFunction':
            \ typevim#make#Member('PublicFunction'),
        \ '__PrivateFunction':
            \ typevim#make#Member('__PrivateFunction'),
        \ }

    return typevim#make#Class('ExampleClass', l:example_prototype)
  endfunction
<

Fourth, implement the rest of the class. In the example given, we referred to
a `PublicFunction()` and a `__PrivateFunction()`, so we implement both here:
>
  " still myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#PublicFunction() dict abort
    " NOTE: `dict` keyword is necessary to have access to l:self variable
    echo 'Hello, World! My number is: ' . l:self['_single_underscore']
  endfunction

  function! myplugin#ExampleClass#__PrivateFunction() dict abort
    " ...
  endfunction
<
Note how the functions are named. In step (3), the calls to
|typevim#make#Member()| return Funcrefs equivalent to
`function('myplugin#ExampleClass#PublicFunction')` and
`function('myplugin#ExampleClass#__PrivateFunction')`, respectively. See
`:help function()` and `:help Funcref` for more details on what this means.

You can see that the full `function('...')` expression is very verbose;
`typevim#make#Member()` is a helper function to help eliminate that
boilerplate.

Finally, test your class, or just start using it!
>
  let ex_1 = myplugin#ExampleObject#new(1, 'foo')
  let ex_2 = myplugin#ExampleObject#new(2, 'boo', 6.28)

  call ex_1.PublicFunction()  " echoes 'Hello, World! My number is: 1'
  call ex_2.PublicFunction()  " echoes 'Hello, World! My number is: 2'
<

==============================================================================
DECLARING A DERIVED CLASS (POLYMORPHISM)                   *TypeVim-poly_decl*


Declaring a derived class is extremely similar to declaring a class normally:
the main difference is that, in a derived class's constructor, one only has to
specify (in addition to the derived class's member variables and functions)
the base class functions that it overrides.

Say that we're declaring a `DerivedClass` that inherits from the
`ExampleClass` declared in |TypeVim-basic_decl|. We could write:
>
  " in myplugin/autoload/myplugin/DerivedClass.vim
  function! myplugin#DerivedClass#New(mem_var) abort
    call maktaba#ensure#IsString(a:mem_var)

    let l:derived_prototype = {
        \ '__mem_var': a:mem_var,
        \ 'PublicFunction':
            \ typevim#make#Member('OverridesPublicFunction'),
        \ 'DerivedClassFunc':
            \ typevim#make#Member('DerivedClassFunc'),
        \ }

    return typevim#make#Derived(
        \ 'DerivedClass', myplugin#ExampleClass#New(), l:example_prototype)
  endfunction
<

This will return an object having `__mem_var`, a member function called
`DerivedClassFunc()`, and all of `ExampleObject`'s functions and member
variables; `ExampleObject`'s `PublicFunction`, however, would be overridden
with `function! myplugin#DerivedClass#OverridesPublicFunction()`.

TypeVim class hierarchies can have arbitrary depth, but TypeVim does not
support multiple inheritance: every type must have at most one immediate
parent type.

PURE VIRTUAL FUNCTIONS
It is possible to define pure virtual functions in TypeVim classes. These
functions are "skeletons" that let you define the virtual function's
interface, but which must be overridden to actually be used.

Say that we wanted `ExampleClass#PublicFunction` to be pure virtual. We could
write:
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " ...
    let l:example_prototype = {
        " ...
        \ 'PublicFunction':
            \ typevim#make#AbstractFunc(
                \ 'ExampleClass', 'PublicFunction', []),
        \ }

    return typevim#make#Class(l:example_prototype)
  endfunction
<

Like |typevim#make#Member()|, |typevim#make#AbstractFunc()| returns a
|Funcref|. However, it returns a Funcref to a special, script-local "skeletal
function": on invocation, this function will either throw
ERROR(InvalidArguments) (or the VimL equivalents) when called with the wrong
number of arguments, or throw `ERROR(NotImplemented)` if called with
appropriate arguments.

The final `[]` in the call to `AbstractFunc` is an arguments list, which can
contain named arguments, optional arguments and a variable-length argslist.
See |typevim#make#AbstractFunc()| for more details.

CLOBBERING BASE CLASS MEMBER VARIABLES
Note that you cannot override a base class's member variables in
`DerivedClass` unless you set {clobber_base_vars} when calling
|typevim#make#Derived()|. This to prevent bugs from accidentally declaring a
member variable in the derived class that was already declared and used in the
base class.

==============================================================================
RESERVED ATTRIBUTES                                         *TypeVim-reserved*

Reserved attributes are properties of TypeVim objects that are "reserved" by
TypeVim for "bookkeeping." These include the attributes used for tracking an
object's dynamic type, its class hierarchy, its order of destructor calls, and
so on.

Users shall not modify these properties, as doing so will lead to undefined
behavior. Attempting to explicitly set the values of these attributes (e.g. in
a class constructor) will sometimes cause TypeVim to throw
ERROR(NotAuthorized) exceptions.

In general, the names of these attributes are fully capitalized and enclosed
in triple-underscores (e.g. `"___TYPE___"`), roughly similar to how Python
names its "dunder methods" (e.g. `"__main__", "__call__"`). Declaring class
members with names that use this format (e.g. declaring an object with a
`"___SIZE___"` property) is strongly discouraged, though not disallowed.

Typenames and identifiers shall not share the name of a reserved attribute.

==============================================================================
ABOUT                                                          *TypeVim-about*

TypeVim is provided under the terms of the MIT license.


vim:tw=78:ts=8:ft=help:norl:

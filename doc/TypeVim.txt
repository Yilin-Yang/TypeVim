*TypeVim.txt*	Don't lose features in translation; use good object-orientation!
Yilin Yang <yiliny@umich.edu>                              *TypeVim* *TypeVim*

==============================================================================
CONTENTS                                                    *TypeVim-contents*
  1. Introduction..............................................|TypeVim-intro|
  2. Summary.................................................|TypeVim-summary|
      1. Differences from Traditional OOP................|TypeVim-differences|
      2. Sugar.................................................|TypeVim-sugar|
      3. Type Information.......................................|TypeVim-type|
  3. Functions.............................................|TypeVim-functions|
  4. Dictionaries..............................................|TypeVim-dicts|
  5. Class Definitions..........................................|TypeVim-make|
      1. Declaring a Class................................|TypeVim-basic_decl|
      2. Declaring a Derived Class (Polymorphism)..........|TypeVim-poly_decl|
      3. Reserved Attributes................................|TypeVim-reserved|
  6. About.....................................................|TypeVim-about|

==============================================================================
INTRODUCTION                                                   *TypeVim-intro*

A library providing a prototype-based class system in VimL.

VimL allows users to assign Funcrefs into a dictionary; these |function|s, if
declared with the |dict| attribute, will be able to access and modify their
"owner" dictionary through a variable (`l:self`) accessible from within their
function body. This allows for object-oriented programming (OOP).

Unfortunately, VimL provides few of the "quality-of-life" features that make
OOP powerful. It lacks type safety, for instance, and lacks explicit support
for OOP features like polymorphism. Implementing these features in VimL is
possible, but involves a great deal of boilerplate.

TypeVim is meant to provide a sensible, standardized framework for "native"
object-oriented programming in VimL.

==============================================================================
SUMMARY                                                      *TypeVim-summary*

TypeVim is not a classical (no pun intended) "class-based" OOP system. TypeVim
is built using VimL's |Dictionary-function|s, which allows for "piecemeal"
construction of objects by assigning |Funcref|s, |Partial|s, and other
variables into |Dictionaries|.

==============================================================================
DIFFERENCES FROM TRADITIONAL OOP                         *TypeVim-differences*

TypeVim is not a classical (no pun intended) "class-based" OOP system. TypeVim
is built using VimL's |Dictionary-function|s, which allows for "piecemeal"
construction of objects by assigning |Funcref|s, |Partial|s, and other
variables into |Dictionaries|.

"NATIVE" VIMSCRIPT CLASSES
VimL does not provide for explicit class declarations, like C++ or Java; it is
much more akin to the type system used in languages like JavaScript. To
declare a "class," one must declare a function ("constructor") that creates a
dict and assigns into it the class's member functions and variables: these
dicts are called *prototypes*. The constructor returns copies of these
prototypes as initialized "class instances."

"Native" (i.e. non-TypeVim) VimL Class instances will lack type information
(like the name of its class) unless assigned such information explicitly, and
nothing prevents the programmer from altering its interface at runtime: by
deleting member functions, altering them, redeclaring them, or adding new ones
entirely.  This allows for JavaScript-esque monkey-patching at runtime, but
can make it difficult to enforce type safety or preserve class invariants.

INHERITANCE
Inheritance, however, is concatenative; "derived classes" are just base class
prototypes with new (or overwritten) member functions and variables. VimL (as
far as I know) does not support behavior delegation, nor does it actually
support JavaScript-esque `[[Prototype]]` chains. An object has, at
construction, all of the class members that it will ever have, unless the user
decides to explicitly alter that object's members at runtime.

CLEAN-UPPERS
Prototype-based type systems, like JavaScript's, generally lack formal
C++-style destructors; the same is true of VimL, and TypeVim by extension. Vim
has its own |garbagecollect()|or that it uses for managing object lifetimes.
This eliminates the need for explicit C++-style memory management on the
programmer's end, but also prevents automatic, customizable RAII-style
destruction when a variable "leaves scope."

For this reason, TypeVim does not support user-declared destructors: instead,
it offers "clean-uppers." Like destructors, clean-uppers perform "end-of-life"
cleanup for an object (e.g. clearing |augroup|s and mappings), but unlike
destructors: (1) they must be called explicitly; and (2) they do not actually
destroy the object. Different clean-uppers can be declared at different points
in a class hierarchy: when calling a class instance's `CleanUp()` function,
those clean-uppers will be called in reverse order, going from the most
derived class up to the base class.

==============================================================================
SUGAR                                                          *TypeVim-sugar*

TypeVim also provides additional "sugar" meant to make OOP easier. As of the
time of writing, this includes: pretty printers (like
|typevim#object#PrettyPrint()| and |typevim#object#ShallowPrint()|) for
printing objects in human-readable fashion; and the |TypeVim.Promise|
datatype.

==============================================================================
TYPE INFORMATION                                                *TypeVim-type*

TypeVim objects are |dictionaries| annotated with a TYPE attribute. As of the
time of writing, this is a |list| containing all of the object's typenames,
ordered from the base class (at index zero) to the most derived class (at the
end of the list). This list should not be modified directly.

Declaring a class in TypeVim is done using helper functions:
|typevim#make#Class()| for base classes, and |typevim#make#Derived()| for
derived classes. The class's typename is a |string| that gets passed to these
functions in the class's constructor. See |TypeVim-make| for more details.

Users can check whether a TypeVim object is an instance of a particular type
using |typevim#value#IsType()|, or assert the same using
|typevim#ensure#IsType()|. Checking whether a given value is a TypeVim object
at all is done using |typevim#value#IsValidObject()|, or the analogous
function from the `ensure` namespace.

==============================================================================
FUNCTIONS                                                  *TypeVim-functions*

typevim#ensure#IsBool({Val})                         *typevim#ensure#IsBool()*
  Throws an ERROR(WrongType) if the given {Val} is not 1, 0, |v:true|, or
  |v:false|. Returns the given {Val} for convenience.

typevim#ensure#IsValidTypename({typename})  *typevim#ensure#IsValidTypename()*
  Throws an ERROR(BadValue) if the given {typename} is not a valid typename,
  along with the reason it's not a valid typename; otherwise, does nothing.

  Returns the given {typename} for convenience.

  Throws ERROR(WrongType) if the given {typename} is not a string.

typevim#ensure#IsValidIdentifier({id})    *typevim#ensure#IsValidIdentifier()*
  Throws an ERROR(BadValue) if the given {id} is not a valid identifier, along
  with the reason it's not a valid identifier; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsValidObject({Val})           *typevim#ensure#IsValidObject()*
  Throws an ERROR(WrongType) if the given {Val} is not a valid TypeVim object.

  Returns {Val} for convenience.

typevim#ensure#IsType({Obj}, {typename})             *typevim#ensure#IsType()*
  Throws an ERROR(WrongType) if the given {Obj} is not an instance of the type
  {typename}.

  Returns {Obj} for convenience.

  Throws ERROR(WrongType) if {Obj} is not a dict or {typename} is not a
  string.

typevim#make#Class({typename}, {prototype}, [CleanUp])  *typevim#make#Class()*
  Return a "typevim-configured" instance of a class. Meant to be called from
  inside a type's constructor, where it will take a {prototype} dictionary
  (containing member functions and member variables), annotate it with type
  information, and perform additional configuration (e.g. adding
  clean-uppers).

  {typename} is the name of the type being declared.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might not be implemented.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object.

  [CleanUp] is 0 if omitted.
  Throws ERROR(BadValue) if the given {typename} is not a valid typename, see
  |typevim#value#IsValidTypename()|.
  Throws ERROR(NotAuthorized) if {prototype} defines attributes that should've
  been initialized by this function.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Derived({typename}, {Parent}, {prototype}, [CleanUp],
  [clobber_base_vars])                                *typevim#make#Derived()*
  Return a "prototypical" instance of a type that inherits from another. Meant
  to be called from inside a type's constructor.

  {typename} is the name of the derived type being declared.

  {Parent} is either a Funcref to the base class constructor, or a base class
  prototype. If arguments must be passed to said constructor, in the former
  case, this should be a Partial.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might be virtual. If the parent class
  defines functions with the same name (i.e. same dictionary key), they will
  be overridden with those of the {prototype}.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object. When invoked, defined clean-uppers will be called in reverse order,
  i.e.  the "most derived" clean-upper will be called first, with the
  "original" base class clean-upper being called last.

  [clobber_base_vars] is a boolean flag that, if true, will allow member
  variables of the base class to be overwritten by member variables of the
  derived class being declared. This is discouraged, since direct access and
  modification of base class member variables is generally considered bad
  style.

  [clobber_base_vars] is 0 if omitted.

  Throws ERROR(BadValue) if {typename} is not a valid typename.
  Throws ERROR(NotAuthorized) when the given {prototype} would redeclare a
  non-Funcref member variable of the base class, and [clobber_base_vars] is
  not 1.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Member({funcname})                        *typevim#make#Member()*
  Return a Funcref to the function with the name constructed by concatenating
  the following: (1) the "autoload prefix" from which this function was called
  (e.g. if called from `~/.vim/bundle/myplugin/autoload/myplugin/foo.vim` the
  prefix would be "myplugin#foo#"); (2) the given {funcname}.

  This is meant as a convenience function to reduce boilerplate when declaring
  TypeVim objects. Instead of long, explicit assignments like,
>
    " ~/.vim/bundle/myplugin/autoload
    function! myplugin#subdirectory#LongClassName#New() abort
      " ...
      let l:new = {
        " ...
        \ 'DoAThing':
            \ function('myplugin#subdirectory#LongClassName#DoAThing'),
      " ...
      return typevim#make#Class(l:new)
    endfunction

    function! myplugin#subdirectory#LongClassName#DoAThing() dict abort
      " ...
<

  One can instead write,
>
      " ...
      let l:new = {
        " ...
        \ 'DoAThing': typevim#make#Member('DoAThing'),
      " ...
<

  Which is functionally equivalent.

typevim#make#AbstractFunc({typename}, {funcname}, {parameters})
                                                 *typevim#make#AbstractFunc()*
  Returns a Partial, assignable into an object with type {typename}, standing
  in for a function named {funcname}, that takes in arguments with the names
  given in {parameters}.

  To specify optional parameters, enclose the parameter name in square
  brackets. To specify that a variable number of arguments are acceptable,
  write "...".

  Example invocation:
>
    let l:new['PureVirtualFunc'] = typevim#make#AbstractFunc(
          \ 'ExampleObject`, 'exampleMethod', '['arg1', '[optional1]', '...'])
<

  An argument list, if specified, must come after all other parameters named.
  Optional parameters, if specified, must come after all non-optional
  parameters, if any.

  Parameters names must be strings and cannot be empty strings, and must be
  valid identifiers (see |typevim#value#IsValidIdentifier()|). They must also
  be unique.

  The returned function, when invoked, will throw: ERROR(InvalidArguments) if
  given the wrong number of arguments (and if Vim itself doesn't throw an
  "|E116|: Invalid arguments for function" exception or an "|E119|: Not enough
  arguments for function" exception); or an ERROR(NotImplemented), if the
  given arguments are valid.

  If the number of arguments is correct, the returned function will throw an
  exception saying that it is an unimplemented virtual function
  Throws ERROR(BadValue) if {parameters} does not adhere to the requirements
  above; or if {typename} s not a valid typename; or if {funcname} is not a
  valid identifier.
  Throws ERROR(WrongType) if {typename} isn't a string or {parameters} isn't a
  list of strings.

typevim#object#Bind({Funcref}, {obj}, [arglist], [argslist], [force_rebind])
                                                       *typevim#object#Bind()*
  Returns a Partial consisting of the given {Funcref} that is bound to this
  particular {obj} and to [arglist], i.e. return `funcref(a:Funcref,
  a:arglist, a:obj)`.

  If the member function is already bound to an argslist, then [argslist] will
  be appended to the function's current argslist.

  If the {Funcref} function is already bound to a dict, throws an
  ERROR(NotAuthorized) exception unless the dict and {obj} are the same
  object; however, if [force_rebind] is 1, the bound dict will be replaced
  with the given {obj}.

  This function is comparable to the `bind()` method on class member functions
  in JavaScript, and to the `std::bind()` function in the C++ standard
  library. Its primary purpose is to extract a "self-contained" class member
  Funcref that "remembers" its original `l:self`, even when it is assigned
  into another object. (This is done frequently in asynchronous event-based
  programming when passing callback functions.)

  See `:help Partial` for an explanation of why it would be bad not to do
  this. (In short, when a "non-bound" Funcref is assigned into another object,
  then when that object calls it, every `l:self` variable in the Funcref's
  definition will point to the NEW object, and NOT to the Funcref's original
  `l:self`; that invocation will then modify that new object as if it were the
  original `l:self`, even if it's of a different class entirely.)

  Note that argument parameters affect the RETURNED Funcref, NOT the Funcref
  that is given as an argument.
>
    " does NOT change obj.Method
    call typevim#object#Bind(obj.Method, diff_obj)

    " DOES change obj.Method
    let obj.Method = typevim#object#Bind(obj.Method, diff_obj)
<

  Throws ERROR(NotAuthorized) if {Funcref} is already bound to a dict that is
  not {obj} and [force_rebind] is 0.
  Throws ERROR(WrongType) if {obj} is not a TypeVim object, or if {Funcref} is
  not a Funcref, or if [arglist] is not a list.

typevim#object#PrettyPrint({object})            *typevim#object#PrettyPrint()*
  Converts the given {object} into a string, suitable for error messages and
  debug logging.

  If it's already a string, encloses the string in quotes (useful when a
  string is purely whitespace). If it's a TypeVim object or a dictionary, adds
  newlines and tabs to make the resulting string human-readable.

typevim#object#ShallowPrint({Obj}, [max_depth])
                                               *typevim#object#ShallowPrint()*
  Like |typevim#object#PrettyPrint()|, but will recurse at most [max_depth]
  levels down into {Obj} if it's a collection or a Partial.

  [max_depth] is 1 if omitted.
  Throws ERROR(BadValue) if [max_depth] is negative.
  Throws ERROR(WrongType) if [max_depth] is not a number.

typevim#value#IsBool({Val})                           *typevim#value#IsBool()*
  Returns 1 if the given {Val} is 1, 0, |v:true|, or |v:false|. Does not
  compare against |v:true| or |v:false| if those constants are not defined in
  the running version of vim.

  This function is provided for use in plugins that use the |v:true| and
  |v:false| constants, because |maktaba#value#IsBool()| will actually fail
  when given |v:true| or |v:false| as inputs: it only accepts a |v:t_number|
  equal to 0 or 1.

typevim#value#IsValidTypename({typename})    *typevim#value#IsValidTypename()*
  Returns 1 when the given {typename} is valid, 0 otherwise.

  A valid typename is a string of uppercase Latin letters, lowercase Latin
  letters, numbers, and underscores. It must start with a capital letter, and
  cannot contain "unusual" characters, e.g. accented Latin letters, emoji,
  etc.

  {typename} cannot be an empty string, nor can it be a "reserved attribute".
  See |TypeVim-reserved| for more details.

typevim#value#IsValidIdentifier({id})      *typevim#value#IsValidIdentifier()*
  Returns 1 when the given {id} is a a valid identifier, 0 otherwise.

  A valid identifier must meet the same requirements as a valid typename (see
  |typevim#value#IsValidTypename()|), but can start with either a lowercase or
  uppercase letter.

typevim#value#IsValidObject({Val})             *typevim#value#IsValidObject()*
  Returns 1 when the given object is a valid TypeVim object, 0 otherwise.

  A valid TypeVim object is a dictionary; it contains a `'TYPE'` entry, also a
  dictionary, whose keys are typenames (see |IsValidTypename()|) and whose
  values can be anything, though it is suggested that they be an arbitrary
  number (typically `1`).

typevim#value#IsType({Obj}, {typename})               *typevim#value#IsType()*
  Returns 1 when the given {Obj} is an instance of the type {typename}, and 0
  otherwise.

  Throws ERROR(BadValue) if {typename} isn't a valid typename.
  Throws ERROR(WrongType) if {typename} isn't a string.

typevim#value#IsPartial({Obj})                     *typevim#value#IsPartial()*
  Returns 1 when the given object is a Partial (see `:help Partial`) and 0
  otherwise.

typevim#value#DecomposePartial({Func})      *typevim#value#DecomposePartial()*
  If the Funcref {Func} is a Partial, decomposes {Func} into a four-element
  list containing: first, the function name; second, the Funcref itself;
  third, the bound arguments; and fourth, the bound dictionary. The latter two
  elements can be empty if {Func} is not bound to arguments or a dictionary,
  respectively.

  Throws ERROR(WrongType) if {Func} is not a Funcref.

typevim#value#GetStackFrame({num_levels_down}, [funcname])
                                               *typevim#value#GetStackFrame()*
  When invoked from a namespaced autoload function, return the name of the
  function {num_levels_down} the callstack, e.g. if called with
  {num_levels_down} = 2, get the callstack (as as string), strip this function
  from its top, then strip the function that called this function from its
  top, and then return the topmost function remaining

  If [funcname] is provided, it will be prefixed with `"#"` and appended to
  the returned string.

  Example inputs and outputs:
>
    function! Foo() abort
      " current callstack: function MainFunc[2]..<SNR>215_ScriptFunc[1]..Foo

      " echoes 'Foo', the name of the calling function
      echo typevim#value#GetStackFrame(0)

      " echoes '<SNR>215_ScriptFunc'
      echo typevim#value#GetStackFrame(1)

      " echoes 'MainFunc'
      echo typevim#value#GetStackFrame(2)

      " ERROR(NotFound)
      echo typevim#value#GetStackFrame(3)
    endfunction
<

  [funcname] is "" if omitted.
  Throws ERROR(NotFound) if there is no stack frame {num_levels_down}.
  Throws ERROR(WrongType) if {num_levels_down} is not a number or [funcname]
  is not a string.

==============================================================================
DICTIONARIES                                                   *TypeVim-dicts*

                                                                *TypeVim.Doer*
A Doer that doesn't do anything, for use with |TypeVim.Promise|. Acts as an
interface, or as a base class for "real" Doer implementations.

In the future, TypeVim may provide Doer's that encapsulate the use of vim
channels and neovim job control.

Doer.New()                                                        *Doer.New()*
  Return a new Doer. Will start after a call to its virtual `StartDoing()`
  member function, which takes no arguments.

  Note that a Doer will not actually start running until a call to
  |Doer.SetCallbacks()|, to ensure that the job does not finish before a
  success (or error) handler has been attached.

Doer.SetCallbacks({Resolve}, {Reject})                   *Doer.SetCallbacks()*
  Set {Resolve} and {Reject} callbacks on this Doer, to be called when this
  Doer resolves or rejects after doing its assigned task.

                                                             *TypeVim.Promise*
A JavaScript-style Promise datatype for handling asynchronous operations.
|TypeVim.Promise| is meant to roughly mimic JavaScript Promise objects in
usage and interface, and is mostly compliant with the Promise/A+ spec.
Deviations from the spec are noted further below.

Because VimScript itself is entirely singlethreaded, Promise is only useful
when used with asynchronous operations, like asynchronous jobs and remote
procedure calls from neovim remote plugins.

PROMISE/A+ DIFFERENCES AND THINGS TO NOTE
These are listed by section, subsection, and clause, using the specification
on https://promisesaplus.com as reference.

2.2) |TypeVim.Promise| tries to adhere to the Google VimScript style guide,
  and names its member functions in UpperCamelCase, including
  |Promise.Then()|. `Promise.then` is an alias of this function, since
  Promise/A+ requires that the `then` function be all lowercase.

2.2.4) |TypeVim.Promise| does not delay `then` callbacks until the callstack
  contains only "platform code." This is mostly for practical reasons, to
  avoid having to write a Promise callback "scheduler."

2.3.1) When resolving a |TypeVim.Promise| with itself, Promise throws an
  ERROR(BadValue) instead of an ERROR(WrongType) (`"TypeError"`). This is for
  better consistency with vim-maktaba, since ERROR(BadValue) makes more sense
  for this case.

2.3.3) |TypeVim.Promise| offers no special handling when resolved with objects
  that have a `then` property, but which are not |TypeVim.Promise|s
  specifically. It will simply pass this object unmodified to its attached
  success handlers.

typevim#Promise#New([Doer])                                    *Promise.New()*
  Return a new Promise that will be fulfilled (or broken) by a given [Doer]
  object, if provided.

  The [Doer] will be initialized (through a call to its `SetCallbacks` method)
  with two Funcrefs: as with JavaScript Promises, these are `Resolve` and
  `Reject`.

  The `Resolve` Funcref, when called by the [Doer], will fulfill ("resolve")
  this Promise with the passed value (e.g. `Resolve("foo")` will pass `"foo"`
  to all attached success handlers).

  The (optional) `Reject` Funcref, when called, will break ("reject") this
  Promise with the passed value (e.g. `Reject("foo")` will pass `"foo"` to all
  attached error handlers).

  `Reject` is optional in that the `Doer.SetCallbacks` function may take
  either one Funcref as an argument (`Resolve`), or two (`Resolve` and
  `Reject`). |TypeVim.Promise| detects this automatically:
>
    " (pseudocode, not actual implementation)
    function! typevim#Promise#NewDoer) abort
      " ...
      try
        Doer.SetCallbacks(self.Resolve, self.Reject)
      catch TooManyArguments
        Doer.SetCallbacks(self.Resolve)
      endtry
      " ...
<

  Note that, unlike JavaScript, [Doer] is an actual object, rather than a
  function. This is meant for convenience; [Doer] is likely to have other
  member functions that it will pass (as callback functions) to, e.g. neovim's
  |jobstart()| function.

  If no [Doer] is provided, then the Promise will only resolve or reject
  through explicit calls to |Promise.Resolve()| and |Promise.Reject()|.

  Throws ERROR(BadValue) if [Doer]'s `SetCallbacks` function does not take
  either one argument or two arguments, or if [Doer] has no `SetCallbacks`
  function.
  Throws ERROR(WrongType) if [Doer] is not an object, or if
  `Doer.SetCallbacks` is not a Funcref.

Promise.Resolve({Val})                                     *Promise.Resolve()*
  Fulfill ("resolve") this Promise. Calls back all attached success handlers
  with the given {Val}, and updates the |Promise.State()| of this Promise to
  `"fulfilled"`.

  If the given {Val} is, itself, a |TypeVim.Promise|, then this Promise will
  "follow" that Promise, i.e. if {Val} resolves, then this Promise will
  resolve with the same value; if {Val} rejects, then this Promise will reject
  with the same value. In either case, this Promise will not resolve
  immediately on this call. Note that this will "expunge" this Promise's
  current |TypeVim.Doer|, if it has one.

  Returns the given {Val}.

  Throws ERROR(BadValue) if the given {Val} is the same as this Promise.
  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.

Promise.Reject({Val})                                       *Promise.Reject()*
  Break ("reject") this Promise. Calls back all attached error handlers with
  the given {Val}, and updates the |Promise.State()| of this Promise to
  `"rejected"`.

  If this Promise has no "live" child Promises (i.e. no "next link" Promises
  with user-attached handlers), AND this Promise does not have any error
  handlers, throws an ERROR(NotFound) due to the unhandled exception.

  Note that, if a |TypeVim.Promise| is passed as {Val}, this function will not
  behave like |Promise.Resolve()|: it will not "wait" for {Val} to resolve or
  reject, but will start immediately calling back its error handlers with
  {Val} as its "reason".

  Returns the given {Val}.

  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.
  Throws ERROR(NotFound) if a valid error handler could not be found.

Promise.Then({Resolve}, [Reject], [chain])                    *Promise.Then()*
  Attach a success handler {Resolve} and optionally an error handler [Reject]
  to this Promise. If this Promise resolves, it will call back {Resolve} with
  the resolved value. If it rejects, it will call back [Reject], or throw an
  ERROR(NotFound) exception due to an unhandled rejection if no [Reject]
  handler was attached.

  If this Promise is already resolved, it will call {Resolve} immediately with
  the resolved value. If it was already rejected, it will call [Reject]
  immediately, or throw an ERROR(NotFound) exception.

  It is strongly suggested that a [Reject] handler be provided in calls to
  this function.

  If {Resolve} is not a Funcref, it will be replaced with a "default" Funcref
  that simply returns (unmodified) whatever value it's given. If [Reject] is
  not a Funcref, then the function will behave as if no error handler was
  given at all.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  value of the given {Resolve} success handler or [Reject] error handler
  respectively, unless [chain] is 0, in which case it will return 0.

  [Reject] is a "null" error handler. if omitted.
  [chain] is 1 if omitted.
  Throws ERROR(WrongType) if {Resolve} or [Reject] are not Funcrefs.

Promise.Catch({Reject}, [chain])                             *Promise.Catch()*
  Attach an error handler {Reject} to this Promise. If this Promise rejects,
  it will call back {Reject} with the provided value. If it was already
  rejected, it will call {Reject} immediately.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  given resolved value the return value of the {Reject} error handler
  respectively, unless [chain] is 0, in which case it returns 0.

  [chain] is 1 if omitted.

Promise.State()                                              *Promise.State()*
  Return the current state of this Promise: `"pending"`, `"fulfilled"`, or
  `"rejected"`.

Promise.Get()                                                  *Promise.Get()*
  Return the stored value/reason from this Promise's resolution/rejection.

  Throws ERROR(NotFound) if this Resolve has not been resolved or rejected.

==============================================================================
CLASS DEFINITIONS                                               *TypeVim-make*

TypeVim offers helper functions for defining new object types. These are meant
to be invoked from within an object's constructor.

==============================================================================
DECLARING A CLASS                                         *TypeVim-basic_decl*

In general, to declare a new class, one should:

First, create a "namespaced" *.vim file for this class, i.e. a file in:
>
  myplugin/  # plugin root dir
    autoload/
      myplugin/  # autoload subdirectory; name matters
        ExampleClass.vim
<
Unless you have a good reason not to, all of `ExampleClass`'s relevant
functions should be declared in `ExampleClass.vim`. This has the benefit of
placing all of `ExampleClass`'s function definitions in an appropriate
"namespace". Based on vim's naming rules for autoload scripts (see `:help
autoload`), a function in `ExampleClass.vim` named `Foo()` will be invocable
through `:call myplugin#ExampleClass#Foo()`."

Second, declare a class constructor. By convention, a class constructor should
be named `New`, e.g. `myplugin#ExampleClass#New()`. It may have any number of
arguments.

Third, inside the constructor, construct a class "prototype." This is a
dictionary object initialized with your class's member variables and functions
(sometimes called "class properties," like in JavaScript):
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " type checking (with vim-maktaba) not required, but strongly encouraged
    call maktaba#ensure#IsNumber(a:num1)
    call maktaba#ensure#IsString(a:str2)

    " optional parameter with a default value of 3.14
    let a:optional_float = maktaba#ensure#IsFloat(get(a:000, 0, 3.14))

    let l:example_prototype = {
        \ '_single_underscore': a:num1,
        \ '_implies_var_is_private': a:str2,
        \ '__double_underscore': a:optional_float,
        \ '__means_definitely_private': 42,
        \ 'PublicFunction':
            \ typevim#PrefixFunc('PublicFunction'),
        \ '__PrivateFunction':
            \ typevim#PrefixFunc('__PrivateFunction'),
        \ }

    return typevim#make#Class(l:example_prototype)
  endfunction
<

Fourth, implement the rest of the class. In the example given, we referred to
a `PublicFunction()` and a `__PrivateFunction()`, so we implement both here:
>
  " still myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#PublicFunction() dict abort
    " NOTE: `dict` keyword is necessary to have access to l:self variable
    echo 'Hello, World! My number is: ' . l:self['_single_underscore']
  endfunction

  function! myplugin#ExampleClass#__PrivateFunction() dict abort
    " ...
  endfunction
<
Note how the functions are named. In step (3), the calls to
|typevim#PrefixFunc()| return Funcrefs equivalent to
`function('myplugin#ExampleClass#PublicFunction')` and
`function('myplugin#ExampleClass#__PrivateFunction')`, respectively. See
`:help function()` and `:help Funcref` for more details on what this means.

You can see that the full `function('...')` expression is very verbose;
`object#PrefixFunc()` is a helper function to help eliminate that boilerplate.

Finally, test your class, or just start using it!
>
  let ex_1 = myplugin#ExampleObject#new(1, 'foo')
  let ex_2 = myplugin#ExampleObject#new(2, 'boo', 6.28)

  call ex_1.PublicFunction()  " echoes 'Hello, World! My number is: 1'
  call ex_2.PublicFunction()  " echoes 'Hello, World! My number is: 2'
<

==============================================================================
DECLARING A DERIVED CLASS (POLYMORPHISM)                   *TypeVim-poly_decl*


Declaring a derived class is extremely similar to declaring a class normally:
the main difference is that, in a derived class's constructor, one only has to
specify (in addition to the derived class's member variables and functions)
the base class functions that it overrides.

Say that we're declaring a `DerivedClass` that inherits from the
`ExampleClass` declared in |TypeVim-basic_decl|. We could write:
>
  " in myplugin/autoload/myplugin/DerivedClass.vim
  function! myplugin#DerivedClass#New(mem_var) abort
    call maktaba#ensure#IsString(a:mem_var)

    let l:derived_prototype = {
        \ '__mem_var': a:mem_var,
        \ 'PublicFunction':
            \ typevim#PrefixFunc('OverridesPublicFunction'),
        \ 'DerivedClassFunc':
            \ typevim#PrefixFunc('DerivedClassFunc'),
        \ }

    return typevim#make#Derived(
        \ 'DerivedClass', myplugin#ExampleClass#New(), l:example_prototype)
  endfunction
<

This will return an object having `__mem_var`, a member function called
`DerivedClassFunc()`, and all of `ExampleObject`'s functions and member
variables; `ExampleObject`'s `PublicFunction`, however, would be overridden
with `function! myplugin#DerivedClass#OverridesPublicFunction()`.

TypeVim class hierarchies can have arbitrary depth, but TypeVim does not
support multiple inheritance: every type must have at most one immediate
parent type.

PURE VIRTUAL FUNCTIONS
It is possible to define pure virtual functions in TypeVim classes. These
functions are "skeletons" that let you define the virtual function's
interface, but which must be overridden to actually be used.

Say that we wanted `ExampleClass#PublicFunction` to be pure virtual. We could
write:
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " ...
    let l:example_prototype = {
        " ...
        \ 'PublicFunction':
            \ typevim#make#AbstractFunc(
                \ 'ExampleClass', 'PublicFunction', []),
        \ }

    return typevim#make#Class(l:example_prototype)
  endfunction
<

Like |typevim#make#Member()|, |typevim#make#AbstractFunc()| returns a
|Funcref|. However, it returns a Funcref to a special, script-local "skeletal
function": on invocation, this function will either throw
ERROR(InvalidArguments) (or the VimL equivalents) when called with the wrong
number of arguments, or throw `ERROR(NotImplemented)` if called with
appropriate arguments.

The final `[]` in the call to `AbstractFunc` is an arguments list, which can
contain named arguments, optional arguments and a variable-length argslist.
See |typevim#make#AbstractFunc()| for more details.

CLOBBERING BASE CLASS MEMBER VARIABLES
Note that you cannot override a base class's member variables in
`DerivedClass` unless you set {clobber_base_vars} when calling
|typevim#make#Derived()|. This to prevent bugs from accidentally declaring a
member variable in the derived class that was already declared and used in the
base class.

==============================================================================
RESERVED ATTRIBUTES                                         *TypeVim-reserved*

Reserved attributes are properties of TypeVim objects that are "reserved" by
TypeVim for "bookkeeping." These include the attributes used for tracking an
object's dynamic type, its class hierarchy, its order of destructor calls, and
so on.

Users shall not modify these properties, as doing so will lead to undefined
behavior. Attempting to explicitly set the values of these attributes (e.g. in
a class constructor) will sometimes cause TypeVim to throw
ERROR(NotAuthorized) exceptions.

In general, the names of these attributes are fully capitalized and enclosed
in triple-underscores (e.g. `"___TYPE___"`), roughly similar to how Python
names its "dunder methods" (e.g. `"__main__", "__call__"`). Declaring class
members with names that use this format (e.g. declaring an object with a
`"___SIZE___"` property) is strongly discouraged, though not disallowed.

Typenames and identifiers shall not share the name of a reserved attribute.

==============================================================================
ABOUT                                                          *TypeVim-about*

TypeVim is provided under the terms of the MIT license.


vim:tw=78:ts=8:ft=help:norl:

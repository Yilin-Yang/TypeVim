*TypeVim.txt*	Object-oriented programming helpers and goodies for VimL.
Yilin Yang <yiliny@umich.edu>                              *TypeVim* *TypeVim*

==============================================================================
CONTENTS                                                    *TypeVim-contents*
  1. Introduction..............................................|TypeVim-intro|
  2. Summary.................................................|TypeVim-summary|
      1. Differences from Traditional OOP................|TypeVim-differences|
      2. Sugar.................................................|TypeVim-sugar|
      3. Type Information.......................................|TypeVim-type|
  3. Functions.............................................|TypeVim-functions|
  4. Dictionaries..............................................|TypeVim-dicts|
  5. Class Definitions..........................................|TypeVim-make|
      1. Declaring a Class................................|TypeVim-basic_decl|
      2. Declaring a Derived Class (Polymorphism)..........|TypeVim-poly_decl|
      3. Reserved Attributes................................|TypeVim-reserved|
  6. About.....................................................|TypeVim-about|

==============================================================================
INTRODUCTION                                                   *TypeVim-intro*

A library providing a prototype-based class system in VimL.

VimL allows users to assign Funcrefs into a dictionary; these |function|s, if
declared with the |dict| attribute, will be able to access and modify their
"owner" dictionary through a variable (`l:self`) accessible from within their
function body. This allows for object-oriented programming (OOP).

Unfortunately, VimL provides few of the "quality-of-life" features that make
OOP powerful. It lacks type safety, for instance, and lacks explicit support
for OOP features like polymorphism. Implementing these features in VimL is
possible, but involves a great deal of boilerplate.

TypeVim is meant to provide a sensible, standardized framework for "native"
object-oriented programming in VimL.

==============================================================================
SUMMARY                                                      *TypeVim-summary*

TypeVim is not a classical (no pun intended) "class-based" OOP system. TypeVim
is built using VimL's |Dictionary-function|s, which allows for "piecemeal"
construction of objects by assigning |Funcref|s, |Partial|s, and other
variables into |Dictionaries|.

==============================================================================
DIFFERENCES FROM TRADITIONAL OOP                         *TypeVim-differences*

TypeVim is not a classical (no pun intended) "class-based" OOP system. TypeVim
is built using VimL's |Dictionary-function|s, which allows for "piecemeal"
construction of objects by assigning |Funcref|s, |Partial|s, and other
variables into |Dictionaries|.

"NATIVE" VIMSCRIPT CLASSES
VimL does not provide for explicit class declarations, like C++ or Java; it is
much more akin to the type system used in languages like JavaScript. To
declare a "class," one must declare a function ("constructor") that creates a
dict and assigns into it the class's member functions and variables: these
dicts are called *prototypes*. The constructor returns copies of these
prototypes as initialized "class instances."

"Native" (i.e. non-TypeVim) VimL Class instances will lack type information
(like the name of its class) unless assigned such information explicitly, and
nothing prevents the programmer from altering its interface at runtime: by
deleting member functions, altering them, redeclaring them, or adding new ones
entirely.  This allows for JavaScript-esque monkey-patching at runtime, but
can make it difficult to enforce type safety or preserve class invariants.

INHERITANCE
Inheritance, however, is concatenative; "derived classes" are just base class
prototypes with new (or overwritten) member functions and variables. VimL (as
far as I know) does not support behavior delegation, nor does it actually
support JavaScript-esque `[[Prototype]]` chains. An object has, at
construction, all of the class members that it will ever have, unless the user
decides to explicitly alter that object's members at runtime.

CLEAN-UPPERS
Prototype-based type systems, like JavaScript's, generally lack formal
C++-style destructors; the same is true of VimL, and TypeVim by extension. Vim
has its own |garbagecollect()|or that it uses for managing object lifetimes.
This eliminates the need for explicit C++-style memory management on the
programmer's end, but also prevents automatic, customizable RAII-style
destruction when a variable "leaves scope."

For this reason, TypeVim does not support user-declared destructors: instead,
it offers "clean-uppers." Like destructors, clean-uppers perform "end-of-life"
cleanup for an object (e.g. clearing |augroup|s and mappings), but unlike
destructors: (1) they must be called explicitly; and (2) they do not actually
destroy the object. Different clean-uppers can be declared at different points
in a class hierarchy: when calling a class instance's `CleanUp()` function,
those clean-uppers will be called in reverse order, going from the most
derived class up to the base class.

All valid TypeVim objects shall have a clean-upper, even if it does nothing.
This is largely handled by TypeVim itself: calls to |typevim#make#Class()| and
|typevim#make#Derived()| will automatically provide dummy clean-uppers if none
are provided.

==============================================================================
SUGAR                                                          *TypeVim-sugar*

TypeVim also provides additional "sugar" meant to make OOP easier. As of the
time of writing, this includes: pretty printers (like
|typevim#object#PrettyPrint()| and |typevim#object#ShallowPrint()|) for
printing objects in human-readable fashion; the object-oriented
|TypeVim.Buffer| wrapper object, including its version-agnostic functions for
editing the wrapped buffer "in the background"; and the |TypeVim.Promise|
datatype.

==============================================================================
TYPE INFORMATION                                                *TypeVim-type*

TypeVim objects are |dictionaries| annotated with a TYPE attribute. As of the
time of writing, this is a |list| containing all of the object's typenames,
ordered from the base class (at index zero) to the most derived class (at the
end of the list). This list should not be modified directly.

Declaring a class in TypeVim is done using helper functions:
|typevim#make#Class()| for base classes, and |typevim#make#Derived()| for
derived classes. The class's typename is a |string| that gets passed to these
functions in the class's constructor. See |TypeVim-make| for more details.

Users can check whether a TypeVim object is an instance of a particular type
using |typevim#value#IsType()|, or assert the same using
|typevim#ensure#IsType()|. Checking whether a given value is a TypeVim object
at all is done using |typevim#value#IsValidObject()|, or the analogous
function from the `ensure` namespace.

==============================================================================
FUNCTIONS                                                  *TypeVim-functions*

typevim#Any()                                                  *typevim#Any()*
  Return a numerical constant representing "any type". As of the time of
  writing, this is the numerical value returned by `type(v:null)` (see
  |type()|), but this may change in the future.

typevim#Bool()                                                *typevim#Bool()*
  Return the numerical value of |v:t_bool|.

typevim#Dict()                                                *typevim#Dict()*
  Return the numerical value of |v:t_dict|.

typevim#Float()                                              *typevim#Float()*
  Return the numerical value of |v:t_float|.

typevim#Func()                                                *typevim#Func()*
  Return the numerical value of |v:t_func|.

typevim#List()                                                *typevim#List()*
  Return the numerical value of |v:t_list|.

typevim#Number()                                            *typevim#Number()*
  Return the numerical value of |v:t_number|.

typevim#String()                                            *typevim#String()*
  Return the numerical value of |v:t_string|.

typevim#ensure#HasPartials()                    *typevim#ensure#HasPartials()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |Partial|s.

  Returns 1.

typevim#ensure#HasLambdas()                      *typevim#ensure#HasLambdas()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |lambda|s.

  Returns 1.

typevim#ensure#HasTypeConstants()          *typevim#ensure#HasTypeConstants()*
  Throws an ERROR(MissingFeature) if the current version of vim does not have
  |v:t_TYPE| constants.

  Returns 1.

typevim#ensure#HasSetBufline()                *typevim#ensure#HasSetBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |setbufline()|.

  Returns 1.

typevim#ensure#HasAppendBufline()          *typevim#ensure#HasAppendBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |appendbufline()|.

  Returns 1.

typevim#ensure#HasDeleteBufline()          *typevim#ensure#HasDeleteBufline()*
  Throws an ERROR(MissingFeature) if the current version of vim does not
  support |deletebufline()|.

  Returns 1.

typevim#ensure#IsBool({Val})                         *typevim#ensure#IsBool()*
  Throws an ERROR(WrongType) if the given {Val} is not 1, 0, |v:true|, or
  |v:false|. Returns the given {Val} for convenience.

typevim#ensure#IsValidTypename({typename})  *typevim#ensure#IsValidTypename()*
  Throws an ERROR(BadValue) if the given {typename} is not a valid typename,
  along with the reason it's not a valid typename; otherwise, does nothing.

  Returns the given {typename} for convenience.

  Throws ERROR(WrongType) if the given {typename} is not a string.

typevim#ensure#IsValidIdentifier({id})    *typevim#ensure#IsValidIdentifier()*
  Throws an ERROR(BadValue) if the given {id} is not a valid identifier, along
  with the reason it's not a valid identifier; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsValidInterfaceProp({id})
                                       *typevim#ensure#IsValidInterfaceProp()*
  Throws an ERROR(BadValue) if the given {id} is not a valid interface
  property with a reason; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsTypeConstant({Val})         *typevim#ensure#IsTypeConstant()*
  Throws an ERROR(WrongType) if the given {Val} is not equal to a |v:t_TYPE|
  constant.

  Returns {Val} for convenience.

typevim#ensure#IsValidObject({Val})           *typevim#ensure#IsValidObject()*
  Throws an ERROR(WrongType) if the given {Val} is not a valid TypeVim object.

  Returns {Val} for convenience.

typevim#ensure#IsType({Obj}, {typename})             *typevim#ensure#IsType()*
  Throws an ERROR(WrongType) if the given {Obj} is not an instance of the type
  {typename}.

  Returns {Obj} for convenience.

  Throws ERROR(BadValue) if {Obj} is not a dict or {typename} is not a string.

typevim#ensure#Implements({Obj}, {Interface})    *typevim#ensure#Implements()*
  Throws an ERROR(WrongType) if the given {Obj} is not an implementation of
  {Interface}.

  Returns {Obj} for convenience.

  Throws ERROR(BadValue) if {Obj} is not a dict or {Interface} is not a
  TypeVim interface.

typevim#make#Class({typename}, {prototype}, [CleanUp])  *typevim#make#Class()*
  Return a "typevim-configured" instance of a class. Meant to be called from
  inside a type's constructor, where it will take a {prototype} dictionary
  (containing member functions and member variables), annotate it with type
  information, perform additional configuration (e.g. adding clean-uppers),
  and return it for convenience.

  {typename} is the name of the type being declared.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might not be implemented.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object, or 0. If [CleanUp] is 0, then the function will substitute a "dummy"
  clean-upper.

  [CleanUp] is 0 if omitted.
  Throws ERROR(BadValue) if the given {typename} is not a valid typename, see
  |typevim#value#IsValidTypename()|.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(NotAuthorized) if {prototype} defines attributes that should've
  been initialized by this function.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Derived({typename}, {Parent}, {prototype}, [CleanUp],
  [clobber_base_vars])                                *typevim#make#Derived()*
  Return a "prototypical" instance of a type that inherits from another. Meant
  to be called from inside a type's constructor.

  {typename} is the name of the derived type being declared.

  {Parent} is either a Funcref to the base class constructor, or a base class
  prototype. If arguments must be passed to said constructor, in the former
  case, this should be a Partial.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might be virtual. If the parent class
  defines functions with the same name (i.e. same dictionary key), they will
  be overridden with those of the {prototype}. The {prototype} dictionary
  given is modified after being passed in, and is returned from this function
  for convenience.

  [CleanUp] is an optional dictionary function that performs cleanup for the
  object, or 0. When invoked, defined clean-uppers will be called in reverse
  order, i.e. the "most derived" clean-upper will be called first, with the
  "original" base class clean-upper being called last. If [CleanUp] is 0, this
  function will substitute a "dummy" clean-upper.

  [clobber_base_vars] is a boolean flag that, if true, will allow member
  variables of the base class to be overwritten by member variables of the
  derived class being declared. This is discouraged, since direct access and
  modification of base class member variables is generally considered bad
  style.

  [CleanUp] is 0 if omitted.
  [clobber_base_vars] is 0 if omitted.

  Throws ERROR(BadValue) if {typename} is not a valid typename.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(NotAuthorized) when the given {prototype} would redeclare a
  non-Funcref member variable of the base class, and [clobber_base_vars] is
  not 1.
  Throws ERROR(WrongType) if arguments don't have the types named above, or if
  the base class {Parent} is not a valid TypeVim object.

typevim#make#Interface({typename}, {prototype})     *typevim#make#Interface()*
  Parse the given {prototype} into an immutable TypeVim interface object that
  can be used in calls to |typevim#value#Implements()| and similar functions.
  The given {prototype} is modified directly, and is returned for convenience.

  The returned object is a TypeVim object with the typename
  `"TypeVimInterface"`. It is made immutable using |lockvar|. It may be
  unlocked through a call to its `CleanUp()` function.

  {typename} is the human-readable name of the interface.

  The structure of {prototype} is similar to that of TypeScript interfaces:

  Each key is the name of a property, and should be a valid identifier (see
  |typescript#value#IsValidIdentifier()|), though each may end with a `"?"` to
  indicate that the property is optional.

  The value associated with that key is called a property constraint, and may
  be a:
  Type constant, that is, a number indicating that property's type in valid
    implementations of the interface, i.e. one of the values of |v:t_TYPE| or
    the value returned by |typevim#Any(()|), or,
  Another TypeVim interface object, or,
  A valid TypeVim interface prototype (which will have the {typename}
    `"INTERFACE_ANON"`), or,
  A nonempty list of type constants and/or TypeVim interface objects and/or
    TypeVim interface prototypes, where each value corresponds to an allowable
    type, or,
  A nonempty list of strings ("tags"), where each string is an allowable value
    for the property (inferred to be of type |v:t_string|).

  When writing an interface {prototype}, one may specify: a built-in
  |v:t_TYPE| constant (e.g. |v:t_dict|, |v:t_func|); the literal number value
  of a |v:t_TYPE| constant (e.g. `1` for |v:t_string|), though this is not
  recommended since it lacks readability; or use TypeVim's helper functions
  (e.g. |typevim#Number()|), which return the same values as vim's built-in
  |v:t_TYPE|s. |typevim#Any(()|) may be used to indicate that any type is
  acceptable.

  The latter is version-agnostic and is recommended for compatibility reasons:
  the |v:t_TYPE| constants are not available in older versions of vim, where
  their use will throw |E121| "Undefined variable" exceptions. The presence of
  the |v:t_TYPE| constants can be checked using
  |typevim#value#HasTypeConstants()|.

  Throws ERROR(BadValue) if keys in {prototype} are not valid identifiers (the
  `"?"` character is valid at the end of these keys, however).
  Throws ERROR(WrongType) if {typename} is not a string, or {prototype} is not
  a dictionary, or if values in {prototype} are not |v:t_TYPE| values or a
  list of |v:t_TYPE| values or a list of strings


typevim#make#Extension({typename}, {base}, {prototype})
                                                    *typevim#make#Extension()*
  Return an interface, with the name {typename}, based on {prototype} that
  extends the given {base} interface. As with |typevim#makeInterface()|, the
  given {prototype} is modified directly and locked using |lockvar|.

  Any object that implements the interface made from {prototype} must
  necessarily implement the {base} interface, i.e. {prototype} cannot impose
  constraints that are incompatible with the {base} interface, such that an
  object cannot implement both interfaces at the same time.

  Throws ERROR(BadValue) if keys in {prototype} are not valid identifiers (the
  `"?"` character is valid at the end of these keys, however).
  Throws ERROR(NotAuthorized) if a property constraint in {prototype} is
  incompatible with a property constraint in {base}.
  Throws ERROR(WrongType) if {typename} is not a string, {base} is not a
  TypeVim interface, or if {prototype} does not satisfy the type checks in
  |typevim#make#Interface()|.

typevim#make#Instance({interface})                   *typevim#make#Instance()*
  Return a mutable object that is an implementation of the given {interface}.
  The returned object will be a "minimal" implementation, having no properties
  not originally found in {interface} (aside from standard TypeVim attributes,
  see |TypeVim-reserved|).

  The instance's typename will be the same as the typename of the interface.

  The value of each object property will be determined from its property
  constraint. If the property constraint is a single type constant:
  |v:t_bool| defaults to (the number) 0.
  |v:t_dict| defaults to `{}`, i.e. an empty dictionary.
  |v:t_float| defaults to `0.0`.
  |v:t_func| defaults to an arbitrary function that takes any number of
    arguments and returns 0.
  |v:t_list| defaults to `[]`, i.e. an empty list.
  |v:t_number| defaults to 0.
  |v:t_string| defaults to ''.
  |typevim#Any()| defaults to 0.

  If the property constraint is a tag list, the value defaults to the first
  tag in the list.

  If the property constraint is a TypeVim interface, the default value is a
  "default" implementation of that interface, as returned by, e.g. a recursive
  call to this function.

  If the property constraint is a list of type constants and/or TypeVim
  interfaces, the default value is populated from the first item in the list,
  e.g. the property:
>
    'someProperty': [v:t_float, v:t_number, g:some_interface]
<
  will default to `0.0`, because |v:t_float| is the first item in the list.

  Throws ERROR(BadValue) if {interface} is not a dict.
  Throws ERROR(WrongType) if {interface} is not a TypeVim interface.

typevim#make#Member({funcname}, [arglist], [dict])     *typevim#make#Member()*
  Return a |Funcref| to the function with the name constructed by
  concatenating the following: (1) the "autoload prefix" from which this
  function was called (e.g. if called from
  `~/.vim/bundle/myplugin/autoload/myplugin/foo.vim` the prefix would be
  "myplugin#foo#"); (2) the given {funcname}.

  If [arglist] or [dict] are provided, they are bound to the returned Funcref,
  turning it into a |Partial|. See |function()|.

  This is meant as a convenience function to reduce boilerplate when declaring
  TypeVim objects. Instead of long, explicit assignments like,
>
    " ~/.vim/bundle/myplugin/autoload
    function! myplugin#subdirectory#LongClassName#New() abort
      " ...
      let l:new = {
        " ...
        \ 'DoAThing':
            \ function('myplugin#subdirectory#LongClassName#DoAThing'),
      " ...
      return typevim#make#Class('LongClassName', l:new)
    endfunction

    function! myplugin#subdirectory#LongClassName#DoAThing() dict abort
      " ...
<

  One can instead write,
>
      " ...
      let l:new = {
        " ...
        \ 'DoAThing': typevim#make#Member('DoAThing'),
      " ...
<

  Which is functionally equivalent.

  [arglist] is [] if omitted.
  [dict] is nothing if omitted.
  Throws ERROR(MissingFeature) if the current version of vim does not support
  |Partial|s.
  Throws ERROR(WrongType) if {funcname} is not a string, or [arglist] is not a
  list, or [dict] is not a dictionary.

typevim#make#AbstractFunc({typename}, {funcname}, {parameters})
                                                 *typevim#make#AbstractFunc()*
  Returns a Partial, assignable into an object with type {typename}, standing
  in for a function named {funcname}, that takes in arguments with the names
  given in {parameters}.

  To specify optional parameters, enclose the parameter name in square
  brackets. To specify that a variable number of arguments are acceptable,
  write "...".

  Example invocation:
>
    let l:new['PureVirtualFunc'] = typevim#make#AbstractFunc(
          \ 'ExampleObject`, 'exampleMethod', '['arg1', '[optional1]', '...'])
<

  An argument list, if specified, must come after all other parameters named.
  Optional parameters, if specified, must come after all non-optional
  parameters, if any.

  Parameters names must be strings and cannot be empty strings, and must be
  valid identifiers (see |typevim#value#IsValidIdentifier()|). They must also
  be unique.

  The returned function, when invoked, will throw: ERROR(InvalidArguments) if
  given the wrong number of arguments (and if Vim itself doesn't throw an
  "|E116|: Invalid arguments for function" exception or an "|E119|: Not enough
  arguments for function" exception); or an ERROR(NotImplemented), if the
  given arguments are valid.

  If the number of arguments is correct, the returned function will throw an
  exception saying that it is an unimplemented virtual function
  Throws ERROR(BadValue) if {parameters} does not adhere to the requirements
  above; or if {typename} s not a valid typename; or if {funcname} is not a
  valid identifier.
  Throws ERROR(WrongType) if {typename} isn't a string or {parameters} isn't a
  list of strings.

typevim#object#Bind({Funcref}, {obj}, [arglist], [argslist], [force_rebind])
                                                       *typevim#object#Bind()*
  Returns a Partial consisting of the given {Funcref} that is bound to this
  particular {obj} and to [arglist], i.e. return `function(a:Funcref,
  a:arglist, a:obj)`.

  If the member function is already bound to an argslist, then [argslist] will
  be appended to the function's current argslist.

  If the {Funcref} function is already bound to a dict, throws an
  ERROR(NotAuthorized) exception unless the dict and {obj} are the same
  object; however, if [force_rebind] is 1, the bound dict will be replaced
  with the given {obj}.

  This function is comparable to the `bind()` method on class member functions
  in JavaScript, and to the `std::bind()` function in the C++ standard
  library. Its primary purpose is to extract a "self-contained" class member
  Funcref that "remembers" its original `l:self`, even when it is assigned
  into another object. (This is done frequently in asynchronous event-based
  programming when passing callback functions.)

  See `:help Partial` for an explanation of why it would be bad not to do
  this. (In short, when a "non-bound" Funcref is assigned into another object,
  then when that object calls it, every `l:self` variable in the Funcref's
  definition will point to the NEW object, and NOT to the Funcref's original
  `l:self`; that invocation will then modify that new object as if it were the
  original `l:self`, even if it's of a different class entirely.)

  Note that argument parameters affect the RETURNED Funcref, NOT the Funcref
  that is given as an argument.
>
    " does NOT change obj.Method
    call typevim#object#Bind(obj.Method, diff_obj)

    " DOES change obj.Method
    let obj.Method = typevim#object#Bind(obj.Method, diff_obj)
<

  Throws ERROR(NotAuthorized) if {Funcref} is already bound to a dict that is
  not {obj} and [force_rebind] is 0.
  Throws ERROR(WrongType) if {obj} is not a TypeVim object, or if {Funcref} is
  not a Funcref, or if [arglist] is not a list.

typevim#object#PrettyPrint({object})            *typevim#object#PrettyPrint()*
  Converts the given {object} into a string, suitable for error messages and
  debug logging.

  If it's already a string, encloses the string in quotes (useful when a
  string is purely whitespace). If it's a TypeVim object or a dictionary, adds
  newlines and tabs to make the resulting string human-readable.

typevim#object#ShallowPrint({Obj}, [max_depth])
                                               *typevim#object#ShallowPrint()*
  Like |typevim#object#PrettyPrint()|, but will recurse at most [max_depth]
  levels down into {Obj} if it's a collection or a Partial.

  [max_depth] is 1 if omitted.
  Throws ERROR(BadValue) if [max_depth] is negative.
  Throws ERROR(WrongType) if [max_depth] is not a number.

typevim#value#HasPartials()                      *typevim#value#HasPartials()*
  Returns 1 if this version of vim supports |Partial| function references AND
  the ability to |get()| the components of a |Partial| or |Funcref| object,
  and 0 otherwise.

typevim#value#HasLambdas()                        *typevim#value#HasLambdas()*
  Returns 1 if this version of vim supports |lambda|s, and 0 otherwise.

typevim#value#HasTypeConstants()            *typevim#value#HasTypeConstants()*
  Returns 1 if this version of vim supports |v:t_TYPE| constants, and 0
  otherwise.

typevim#value#HasSetBufline()                  *typevim#value#HasSetBufline()*
  Returns 1 if this version of vim supports |setbufline|, and 0 otherwise.

typevim#value#HasAppendBufline()            *typevim#value#HasAppendBufline()*
  Returns 1 if this version of vim supports |appendbufline|, and 0 otherwise.

typevim#value#HasDeleteBufline()            *typevim#value#HasDeleteBufline()*
  Returns 1 if this version of vim supports |deletebufline|, and 0 otherwise.

typevim#value#IsBool({Val})                           *typevim#value#IsBool()*
  Returns 1 if the given {Val} is 1, 0, |v:true|, or |v:false|. Does not
  compare against |v:true| or |v:false| if those constants are not defined in
  the running version of vim.

  This function is provided for use in plugins that use the |v:true| and
  |v:false| constants, because |maktaba#value#IsBool()| will actually fail
  when given |v:true| or |v:false| as inputs: it only accepts a |v:t_number|
  equal to 0 or 1.

typevim#value#IsValidTypename({Typename})    *typevim#value#IsValidTypename()*
  Returns 1 when the given {Typename} is valid, 0 otherwise.

  A valid typename is a string of uppercase Latin letters, lowercase Latin
  letters, numbers, and underscores. It must start with a capital letter, and
  cannot contain "unusual" characters, e.g. accented Latin letters, emoji,
  etc.

  {Typename} cannot be an empty string, nor can it be a "reserved attribute".
  See |TypeVim-reserved| for more details.

typevim#value#IsValidIdentifier({Id})      *typevim#value#IsValidIdentifier()*
  Returns 1 when the given {Id} is a a valid identifier, 0 otherwise.

  A valid identifier must meet the same requirements as a valid typename (see
  |typevim#value#IsValidTypename()|), but can start with either a lowercase or
  uppercase letter.

typevim#value#IsValidInterfaceProp({Id})
                                        *typevim#value#IsValidInterfaceProp()*
  Returns 1 when the given {Id} is a a valid interface property, 0 otherwise.

  A valid interface property must meet the same requirements as a valid
  identifier (see |typevim#value#IsValidTypename()|), but can end with a
  question mark.

typevim#value#IsTypeConstant({Val})           *typevim#value#IsTypeConstant()*
  Returns 1 when the given {Val} is a number equal to a valid |v:t_TYPE|
  constant or |typevim#Any()|, and 0 otherwise.

typevim#value#IsValidObject({Val})             *typevim#value#IsValidObject()*
  Returns 1 when the given object is a valid TypeVim object, 0 otherwise.

  A valid TypeVim object is a dictionary. It shall contain the following
  attributes:
  A TYPE list: a list of strings containing the names of every class in the
    object's class hierarchy, with the original base class as the first
    element and the "most derived" class as the last.
  A CLEAN-UPPER: a member function, taking no arguments, that handles clean-up
    for the object. This function may do nothing: if, for instance,
    |typevim#make#Class()| is not given a clean-upper, the resulting object
    will be given a "dummy" clean-upper.

  See |TypeVim-reserved| for more details.

typevim#value#IsType({Obj}, {typename})               *typevim#value#IsType()*
  Returns 1 when the given {Obj} is an instance of the type {typename}, and 0
  otherwise.

  Throws ERROR(BadValue) if {typename} isn't a valid typename.
  Throws ERROR(WrongType) if {typename} isn't a string.

typevim#value#Implements({Obj}, {Interface})      *typevim#value#Implements()*
  Returns 1 when {Obj} is an implementation of {Interface}, and 0 otherwise.

  Throws ERROR(WrongType) if {Obj} is not a dictionary, or if {Interface} is
  not a TypeVim interface (i.e. an object constructed through a call to
  |typevim#make#Interface()|.)

typevim#value#IsPartial({Obj})                     *typevim#value#IsPartial()*
  Returns 1 when the given object is a Partial (see `:help Partial`) and 0
  otherwise.

typevim#value#DecomposePartial({Func})      *typevim#value#DecomposePartial()*
  If the Funcref {Func} is a Partial, decomposes {Func} into a four-element
  list containing: first, the function name; second, the Funcref itself;
  third, the bound arguments; and fourth, the bound dictionary. The latter two
  elements can be empty if {Func} is not bound to arguments or a dictionary,
  respectively.

  Throws ERROR(WrongType) if {Func} is not a Funcref.

typevim#value#GetStackFrame({num_levels_down}) *typevim#value#GetStackFrame()*
  When invoked from a namespaced autoload function, return the name of the
  function {num_levels_down} the callstack, e.g. if called with
  {num_levels_down} = 2, get the callstack (as as string), strip this function
  from its top, then strip the function that called this function from its
  top, and then return the topmost function remaining

  Example inputs and outputs:
>
    function! Foo() abort
      " current callstack: function MainFunc[2]..<SNR>215_ScriptFunc[1]..Foo

      " echoes 'Foo', the name of the calling function
      echo typevim#value#GetStackFrame(0)

      " echoes '<SNR>215_ScriptFunc'
      echo typevim#value#GetStackFrame(1)

      " echoes 'MainFunc'
      echo typevim#value#GetStackFrame(2)

      " ERROR(NotFound)
      echo typevim#value#GetStackFrame(3)
    endfunction
<

  Throws ERROR(NotFound) if there is no stack frame {num_levels_down}.
  Throws ERROR(WrongType) if {num_levels_down} is not a number.

==============================================================================
DICTIONARIES                                                   *TypeVim-dicts*

                                                              *TypeVim.Buffer*
An encapsulation of a vim buffer; allows for manipulation of vim buffers as if
they were objects.

typevim#Buffer#New([properties])                                *Buffer.New()*
  Construct and return a new Buffer object. |TypeVim.Buffer| objects can
  either create their own |buffers| on construction, or be "given" a buffer by
  specifying the `fname` of an existing buffer through the `fname` property of
  [properties].

  [properties] is a dictionary whose keys and values are used to configure the
  new buffer. These include:

  `bufhidden`: A string. The buffer's |bufhidden| setting. Defaults to `hide`.
  `buflisted`: A boolean. The buffer's |buflisted| setting. Defaults to 0.
  `bufname`: A string. The name to be given to the buffer. If empty, the
    buffer will be given a name that is arbitrary, but unique.
  `bufnr`: A number. If empty or zero, then this |TypeVim.Buffer| will be
    initialized with a new vim buffer. This can be set to a nonzero value to
    give this |TypeVim.Buffer| ownership of an existing vim buffer with that
    |bufnr|. Defaults to 0.
  `buftype`: A string. The buffer's |buftype| setting. Defaults to `nofile`.
  `swapfile`: A boolean. The buffer's |swapfile| setting. Defaults to 0.

  All of these are optional and will have default values if not specified.
  Properties which are also vim settings can have any value that could be
  assigned to those settings explicitly, e.g. with `let &bufhidden = [...]`.

  If constructing a new buffer (i.e. `bufnr` is 0), then the given properties
  will be set on that buffer. If given an existing buffer (i.e. this
  |TypeVim.Buffer| is being given the buffer with |bufnr| 3, so `bufnr` is 3),
  then this function will try to set those properties on that buffer (e.g.
  change the buffer's |bufname|, change the buffer's |swapfile|). The latter
  may fail and throw an exception.

  [properties] is {} if omitted.
  Throws ERROR(BadValue) if the given `bufname` matches an existing buffer
  that isn't `bufnr` (when nonzero), this function will throw an
  ERROR(BadValue).
  Throws ERROR(WrongType) if the type of a value in [properties] doesn't match
  the list above.

Buffer.CleanUp()                                            *Buffer.CleanUp()*
  Perform cleanup for this Buffer object.

Buffer.getbufvar({varname}, [default])                    *Buffer.getbufvar()*
  Invoke `getbufvar` on this Buffer's stored buffer with the given arguments.
  See `:h getbufvar` for argument details.
  Throws ERROR(WrongType) if {varname} is not a string.

Buffer.setbufvar({varname}, {Val})                        *Buffer.setbufvar()*
  Invoke `setbufvar` on this Buffer's stored buffer with the given arguments.
  See `:h setbufvar` for argument details.
  Throws ERROR(WrongType) if {varname} is not a string.

Buffer.bufnr()                                                *Buffer.bufnr()*
  Returns the |bufnr| of the buffer owned by this |TypeVim.Buffer|.

  Throws ERROR(NotFound) if this |TypeVim.Buffer|'s buffer no longer exists.

Buffer.Open([cmd], [keepalt])                                  *Buffer.Open()*
  Open this buffer in the currently focused window.

  For details on [cmd], see `:h buffer`. [cmd] should include a leading `+`.
  If [keepalt] is 1, then the current alternate buffer will be preserved. See
  |keepalt|.

Buffer.Switch([open_in_any], [tabnr])                        *Buffer.Switch()*
  Move the cursor to (one of) this buffer's window(s) in the given tab.

  If [open_in_any] is 1, then it is "acceptable" for this function to switch
  to a window in a different tabpage if that window has this buffer open.

  Prefers to switch to a buffer in the current tabpage, or the tabpage with
  the given [tabnr] if possible. Does nothing if the current tabpage is
  "acceptable" and the current window has this buffer open.

  [open_in_any] is 0 if omitted.
  [tabnr] is the current tabpage if omitted.
  Throws ERROR(NotFound) if this buffer isn't open in the tab(s) specified.
  Throws ERROR(WrongType) if [open_in_any] is not a boolean, or if [tabnr] is
  not a number.

Buffer.SetBuffer({bufnr}, [action], [force])              *Buffer.SetBuffer()*
  Replace the buffer owned by this Buffer object with {bufnr}.

  [action] controls what happens to the buffer being replaced. It can be an
  empty string, `"bunload"`, `"bdelete"`, or `"bwipeout"`: these will do
  nothing, |bunload|, |bdelete|, or |bwipeout| the replaced buffer,
  respectively.

  If [force] is 1, unsaved changes in the replaced buffer will be ignored when
  unloading, deleting, or wiping the buffer out.

  Returns the |bufnr| of the replaced buffer.

  [action] is "" if omitted.
  [force] is 0 if omitted.
  Throws ERROR(BadValue) if [action] is not one of the values listed above.
  Throws ERROR(NotFound) if the given {bufnr} doesn't correspond to a real
  buffer.
  Throws ERROR(WrongType) if {bufnr} is not a number, if [action] is not a
  string, or if [force] is not a boolean.

Buffer.OpenSplit({open_vertical}, [cmd], [pos], [size])   *Buffer.OpenSplit()*
  Open this buffer in a split.

  If {open_vertical} is 1, opens in a vertical split; if {open_vertical} is 0,
  opens in a horizontal split.

  For [cmd], see `:h +cmd`. It may be empty string, and should include a
  leading `"+"` character.

  [pos] is the part of the screen in which the split should be created. See
  `:h topleft` and `:h botright`. It may be the empty string.

  [size] is the height/width of the horizontal/vertical split to be created.
  If 0, this parameter will be ignored.

  [cmd] is "" if omitted.
  [pos] is "" if omitted.
  [size] is 0 if omitted.

  Throws ERROR(BadValue) if [pos] is not "leftabove", "aboveleft",
  "rightbelow", "belowright", "topleft", or "botright".
  Throws ERROR(WrongType) if {open_vertical} is not a boolean, if [cmd] is not
  a string, if [pos] is not a string, or if [size] is not a number.

Buffer.NumLines()                                          *Buffer.NumLines()*
  Return the total number of lines in this buffer.

Buffer.GetLines({startline}, [endline], [strict_indexing]) *Buffer.GetLines()*
  Return lines {startline} to [endline], end-inclusive, from this buffer as a
  list of strings. If [strict_indexing] is 1, throw exceptions when requesting
  a line from "out of range."

Buffer.ReplaceLines({startline}, {endline}, {replacement})
                                                       *Buffer.ReplaceLines()*
  Change, add, or remove lines from this buffer, replacing lines {startline}
  through {endline}, end-inclusive, with the given {replacement}, a list of
  strings (one string per line).

  The number of lines in {replacement} can be does not need to be equal to
  `endline - startline + 1`, i.e. this function can replace part of a buffer
  with more lines than were originally there, or with fewer. For instance, if
  {replacement} is an empty list, the given line range will be deleted.

  Indexing is one-based: line 1 is the first line of the buffer. {startline}
  and {endline} can assume negative values; -1 is the last line of the buffer,
  -2 is the second-to-last line, and so on. 0 and `"$"` are not accepted
  values.

  Throws ERROR(BadValue) if the {startline} is positioned after the {endline}
  in the buffer, or if the given lines are out of range for the current
  buffer, or if {startline} or {endline} are 0.
  Throws ERROR(WrongType) if {startline} or {endline} are not numbers, or if
  {replacement} is not a list of strings.

Buffer.InsertLines({after}, {lines})                    *Buffer.InsertLines()*
  Insert the given {lines} just below line {after}. Similar to
  |Buffer.ReplaceLines()|, except that it does not overwrite any of the lines
  in the buffer.

  This function uses the same indexing scheme |Buffer.ReplaceLines()|, with
  the following additions:

  {after} may be 0, which is the "line before-the-start" of the buffer. If
    {after} is 0, then the given {lines} will be prepended to the start of the
    buffer, i.e. above line 1.
  {after} may be `"$"`, which is the "line after-the-end" of the buffer. If
    {after} is `"$"`, then the given {lines} will be appended to the end of
    the buffer. (Note that you can also specify -1, or just explicitly specify
    the line number of the last line in the buffer.)

  Throws ERROR(WrongType) if {after} is not a number or `"$"`, or if {lines}
  is not a list.

Buffer.DeleteLines({startline}, {endline})              *Buffer.DeleteLines()*
  Delete lines {startline} through {endline}, end-inclusive.

  See |Buffer.ReplaceLines()| for details on exceptions and indexing.

Buffer.IsOpenInTab([tabnr])                             *Buffer.IsOpenInTab()*
  Returns 1 if this |TypeVim.Buffer| is open in the tabpage with the given
  [tabnr], and 0 otherwise. If the buffer owned by this |TypeVim.Buffer| no
  longer exists, return 0.

  [tabnr] is the current tabpage if omitted.
  Throws ERROR(BadValue) if [tabnr] is less than 1.
  Throws ERROR(WrongType) if [tabnr] is not a number.

                                                                *TypeVim.Doer*
A Doer that doesn't do anything, for use with |TypeVim.Promise|. Acts as an
interface, or as a base class for "real" Doer implementations.

In the future, TypeVim may provide Doer's that encapsulate the use of vim
channels and neovim job control.

Doer.New()                                                        *Doer.New()*
  Return a new Doer. Will start after a call to its virtual `StartDoing()`
  member function, which takes no arguments.

  Note that a Doer will not actually start running until a call to
  |Doer.SetCallbacks()|, to ensure that the job does not finish before a
  success (or error) handler has been attached.

Doer.SetCallbacks({Resolve}, {Reject})                   *Doer.SetCallbacks()*
  Set {Resolve} and {Reject} callbacks on this Doer, to be called when this
  Doer resolves or rejects after doing its assigned task.

                                                             *TypeVim.Promise*
A JavaScript-style Promise datatype for handling asynchronous operations.
|TypeVim.Promise| is meant to roughly mimic JavaScript Promise objects in
usage and interface, and is mostly compliant with the Promise/A+ spec.
Deviations from the spec are noted further below.

Because VimScript itself is entirely singlethreaded, Promise is only useful
when used with asynchronous operations, like asynchronous jobs and remote
procedure calls from neovim remote plugins.

PROMISE/A+ DIFFERENCES AND THINGS TO NOTE
These are listed by section, subsection, and clause, using the specification
on https://promisesaplus.com as reference.

2.2) |TypeVim.Promise| tries to adhere to the Google VimScript style guide,
  and names its member functions in UpperCamelCase, including
  |Promise.Then()|. `Promise.then()` is an alias of this function, since
  Promise/A+ requires that the `then` function be all lowercase.

2.2.4) |TypeVim.Promise| does not delay `then()` callbacks until the callstack
  "contains only platform code." This is mostly for practical reasons, to
  avoid having to write a Promise callback "scheduler."

2.3.1) When resolving a |TypeVim.Promise| with itself, Promise throws an
  ERROR(BadValue) instead of an ERROR(WrongType) (`"TypeError"`). This is for
  better consistency with vim-maktaba, since ERROR(BadValue) better describes
  the nature of the error.

2.3.3) |TypeVim.Promise| offers no special handling when resolved with objects
  that possess a `then` property, but which are not |TypeVim.Promise|s
  instances specifically. It will simply pass this object unmodified to its
  attached success handlers.

typevim#Promise#New([Doer])                                    *Promise.New()*
  Return a new Promise that will be fulfilled (or broken) by a given [Doer]
  object, if provided.

  The [Doer] will be initialized (through a call to its `SetCallbacks` method)
  with two Funcrefs: `Resolve` and `Reject`.

  The `Resolve` Funcref, when called by the [Doer], will fulfill ("resolve")
  this Promise with the passed value (e.g. `Resolve("foo")` will pass `"foo"`
  to all attached success handlers).

  The (optional) `Reject` Funcref, when called, will break ("reject") this
  Promise with the passed value (e.g. `Reject("foo")` will pass `"foo"` to all
  attached error handlers).

  `Reject` is optional in that the `Doer.SetCallbacks` function may take
  either one Funcref as an argument (`Resolve`), or two (`Resolve` and
  `Reject`). |TypeVim.Promise| detects this automatically:
>
    " (pseudocode, not actual implementation)
    function! typevim#Promise#NewDoer() abort
      " ...
      try
        Doer.SetCallbacks(self.Resolve, self.Reject)
      catch TooManyArguments
        Doer.SetCallbacks(self.Resolve)
      endtry
      " ...
<

  Note that, unlike JavaScript, [Doer] is an actual object, rather than a
  function. This is meant for convenience; [Doer] is likely to have other
  member functions that it will pass (as callback functions) to, e.g. neovim's
  |jobstart()| function.

  If no [Doer] is provided, then the Promise will only resolve or reject
  through explicit calls to |Promise.Resolve()| and |Promise.Reject()|.

  Throws ERROR(BadValue) if [Doer]'s `SetCallbacks` function does not take
  either one argument or two arguments, or if [Doer] has no `SetCallbacks`
  function.
  Throws ERROR(WrongType) if [Doer] is not an object, or if
  `Doer.SetCallbacks` is not a Funcref.

Promise.Resolve({Val})                                     *Promise.Resolve()*
  Fulfill ("resolve") this Promise. Calls back all attached success handlers
  with the given {Val}, and updates the |Promise.State()| of this Promise to
  `"fulfilled"`.

  If the given {Val} is, itself, a |TypeVim.Promise|, then this Promise will
  "follow" that Promise, i.e. if {Val} resolves, then this Promise will
  resolve with the same value; if {Val} rejects, then this Promise will reject
  with the same value. In either case, this Promise will not resolve
  immediately on this call. Note that this will "expunge" this Promise's
  current |TypeVim.Doer|, if it has one.

  Returns the given {Val}.

  Throws ERROR(BadValue) if the given {Val} is the same as this Promise.
  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.

Promise.Reject({Val})                                       *Promise.Reject()*
  Break ("reject") this Promise. Calls back all attached error handlers with
  the given {Val}, and updates the |Promise.State()| of this Promise to
  `"rejected"`.

  If this Promise has no "live" child Promises (i.e. no "next link" Promises
  with user-attached handlers), AND this Promise does not have any error
  handlers, throws an ERROR(NotFound) due to the unhandled exception.

  Note that, if a |TypeVim.Promise| is passed as {Val}, this function will not
  behave like |Promise.Resolve()|: it will not "wait" for {Val} to resolve or
  reject, but will start immediately calling back its error handlers with
  {Val} as its "reason".

  Returns the given {Val}.

  Throws ERROR(NotAuthorized) if this Promise was already resolved or
  rejected.
  Throws ERROR(NotFound) if a valid error handler could not be found.

Promise.Then({Resolve}, [Reject], [chain])                    *Promise.Then()*
  Attach a success handler {Resolve} and optionally an error handler [Reject]
  to this Promise. If this Promise resolves, it will call back {Resolve} with
  the resolved value. If it rejects, it will call back [Reject], or throw an
  ERROR(NotFound) exception due to an unhandled rejection if there are no
  [Reject] error handlers "in the chain." (See |Promise.Reject()|.)

  If this Promise is already resolved, it will call {Resolve} immediately with
  the resolved value. If it was already rejected, it will call [Reject]
  immediately, or throw an ERROR(NotFound) exception.

  It is strongly suggested that a [Reject] handler be provided in calls to
  this function.

  If {Resolve} is not a Funcref, it will be replaced with a "default" Funcref
  that simply returns (unmodified) whatever value it's given. If [Reject] is
  not a Funcref, then the function will behave as if no error handler was
  given at all.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  value of the given {Resolve} success handler or [Reject] error handler
  respectively, unless [chain] is 0, in which case it will return 0.

  [Reject] is a "null" error handler. if omitted.
  [chain] is 1 if omitted.
  Throws ERROR(WrongType) if {Resolve} or [Reject] are not Funcrefs.

Promise.Catch({Reject}, [chain])                             *Promise.Catch()*
  Attach an error handler {Reject} to this Promise. If this Promise rejects,
  it will call back {Reject} with the provided value. If it was already
  rejected, it will call {Reject} immediately.

  Returns a "child" Promise that will be fulfilled, or rejected, with the
  given resolved value the return value of the {Reject} error handler
  respectively, unless [chain] is 0, in which case it returns 0.

  [chain] is 1 if omitted.

Promise.State()                                              *Promise.State()*
  Return the current state of this Promise: `"pending"`, `"fulfilled"`, or
  `"rejected"`.

Promise.Get()                                                  *Promise.Get()*
  Return the stored value/reason from this Promise's resolution/rejection.

  Throws ERROR(NotFound) if this Promise has not been resolved or rejected.

==============================================================================
CLASS DEFINITIONS                                               *TypeVim-make*

TypeVim offers helper functions for defining new object types. These are meant
to be invoked from within an object's constructor.

==============================================================================
DECLARING A CLASS                                         *TypeVim-basic_decl*

In general, to declare a new class, one should:

First, create a "namespaced" *.vim file for this class, i.e. a file in:
>
  myplugin/  # plugin root dir
    autoload/
      myplugin/  # autoload subdirectory; name matters
        ExampleClass.vim
<
Unless you have a good reason not to, all of `ExampleClass`'s relevant
functions should be declared in `ExampleClass.vim`. This has the benefit of
placing all of `ExampleClass`'s function definitions in an appropriate
"namespace". Based on vim's naming rules for autoload scripts (see `:help
autoload`), a function in `ExampleClass.vim` named `Foo()` will be invocable
through `:call myplugin#ExampleClass#Foo()`."

Second, declare a class constructor. By convention, a class constructor should
be named `New`, e.g. `myplugin#ExampleClass#New()`. It may have any number of
arguments.

Third, inside the constructor, construct a class "prototype." This is a
dictionary object initialized with your class's member variables and functions
(sometimes called "class properties," like in JavaScript):
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " type checking (with vim-maktaba) not required, but strongly encouraged
    call maktaba#ensure#IsNumber(a:num1)
    call maktaba#ensure#IsString(a:str2)

    " optional parameter with a default value of 3.14
    let l:optional_float = maktaba#ensure#IsFloat(get(a:000, 0, 3.14))

    let l:example_prototype = {
        \ '_single_underscore': a:num1,
        \ '_implies_var_is_private': a:str2,
        \ '__double_underscore': l:optional_float,
        \ '__means_definitely_private': 42,
        \ 'PublicFunction':
            \ typevim#make#Member('PublicFunction'),
        \ '__PrivateFunction':
            \ typevim#make#Member('__PrivateFunction'),
        \ }

    return typevim#make#Class('ExampleClass', l:example_prototype)
  endfunction
<

Fourth, implement the rest of the class. In the example given, we referred to
a `PublicFunction()` and a `__PrivateFunction()`, so we implement both here:
>
  " still myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#PublicFunction() dict abort
    " NOTE: `dict` keyword is necessary to have access to l:self variable
    echo 'Hello, World! My number is: ' . l:self['_single_underscore']
  endfunction

  function! myplugin#ExampleClass#__PrivateFunction() dict abort
    " ...
  endfunction
<
Note how the functions are named. In step (3), the calls to
|typevim#make#Member()| return Funcrefs equivalent to
`function('myplugin#ExampleClass#PublicFunction')` and
`function('myplugin#ExampleClass#__PrivateFunction')`, respectively. See
`:help function()` and `:help Funcref` for more details on what this means.

You can see that the full `function('...')` expression is very verbose;
`typevim#make#Member()` is a helper function to help eliminate that
boilerplate.

Finally, test your class, or just start using it!
>
  let ex_1 = myplugin#ExampleObject#new(1, 'foo')
  let ex_2 = myplugin#ExampleObject#new(2, 'boo', 6.28)

  call ex_1.PublicFunction()  " echoes 'Hello, World! My number is: 1'
  call ex_2.PublicFunction()  " echoes 'Hello, World! My number is: 2'
<

==============================================================================
DECLARING A DERIVED CLASS (POLYMORPHISM)                   *TypeVim-poly_decl*


Declaring a derived class is extremely similar to declaring a class normally:
the main difference is that, in a derived class's constructor, one only has to
specify (in addition to the derived class's member variables and functions)
the base class functions that it overrides.

Say that we're declaring a `DerivedClass` that inherits from the
`ExampleClass` declared in |TypeVim-basic_decl|. We could write:
>
  " in myplugin/autoload/myplugin/DerivedClass.vim
  function! myplugin#DerivedClass#New(mem_var) abort
    call maktaba#ensure#IsString(a:mem_var)

    let l:derived_prototype = {
        \ '__mem_var': a:mem_var,
        \ 'PublicFunction':
            \ typevim#make#Member('OverridesPublicFunction'),
        \ 'DerivedClassFunc':
            \ typevim#make#Member('DerivedClassFunc'),
        \ }

    return typevim#make#Derived(
        \ 'DerivedClass', myplugin#ExampleClass#New(), l:example_prototype)
  endfunction
<

This will return an object having `__mem_var`, a member function called
`DerivedClassFunc()`, and all of `ExampleObject`'s functions and member
variables; `ExampleObject`'s `PublicFunction`, however, would be overridden
with `function! myplugin#DerivedClass#OverridesPublicFunction()`.

TypeVim class hierarchies can have arbitrary depth, but TypeVim does not
support multiple inheritance: every type must have at most one immediate
parent type.

PURE VIRTUAL FUNCTIONS
It is possible to define pure virtual functions in TypeVim classes. These
functions are "skeletons" that let you define the virtual function's
interface, but which must be overridden to actually be used.

Say that we wanted `ExampleClass#PublicFunction` to be pure virtual. We could
write:
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " ...
    let l:example_prototype = {
        " ...
        \ 'PublicFunction':
            \ typevim#make#AbstractFunc(
                \ 'ExampleClass', 'PublicFunction', []),
        \ }

    return typevim#make#Class(l:example_prototype)
  endfunction
<

Like |typevim#make#Member()|, |typevim#make#AbstractFunc()| returns a
|Funcref|. However, it returns a Funcref to a special, script-local "skeletal
function": on invocation, this function will either throw
ERROR(InvalidArguments) (or the VimL equivalents) when called with the wrong
number of arguments, or throw `ERROR(NotImplemented)` if called with
appropriate arguments.

The final `[]` in the call to `AbstractFunc` is an arguments list, which can
contain named arguments, optional arguments and a variable-length argslist.
See |typevim#make#AbstractFunc()| for more details.

CLOBBERING BASE CLASS MEMBER VARIABLES
Note that you cannot override a base class's member variables in
`DerivedClass` unless you set {clobber_base_vars} when calling
|typevim#make#Derived()|. This to prevent bugs from accidentally declaring a
member variable in the derived class that was already declared and used in the
base class.

==============================================================================
RESERVED ATTRIBUTES                                         *TypeVim-reserved*

Reserved attributes are properties of TypeVim objects that are "reserved" by
TypeVim for "bookkeeping." These include the attributes used for tracking an
object's dynamic type, its class hierarchy, its order of destructor calls, and
so on.

Users shall not modify these properties, as doing so will lead to undefined
behavior. Attempting to explicitly set the values of these attributes (e.g. in
a class constructor) will sometimes cause TypeVim to throw
ERROR(NotAuthorized) exceptions.

In general, the names of these attributes are fully capitalized and enclosed
in triple-underscores (e.g. `"___TYPE___"`), roughly similar to how Python
names its "dunder methods" (e.g. `"__main__", "__call__"`). Declaring class
members with names that use this format (e.g. declaring an object with a
`"___SIZE___"` property) is strongly discouraged, though not disallowed.

Typenames and identifiers shall not share the name of a reserved attribute.

==============================================================================
ABOUT                                                          *TypeVim-about*

TypeVim is provided under the terms of the MIT license.


vim:tw=78:ts=8:ft=help:norl:

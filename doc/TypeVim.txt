*TypeVim.txt*	Don't lose features in translation; use good object-orientation!
Yilin Yang <yiliny@umich.edu>                              *TypeVim* *TypeVim*

==============================================================================
CONTENTS                                                    *TypeVim-contents*
  1. Introduction..............................................|TypeVim-intro|
  2. Configuration............................................|TypeVim-config|
  3. Dictionaries..............................................|TypeVim-dicts|
  4. Functions.............................................|TypeVim-functions|
  5. Class Definitions..........................................|TypeVim-make|
      1. Declaring a Class................................|TypeVim-basic_decl|
      2. Declaring a Derived Class (Polymorphism)..........|TypeVim-poly_decl|
      3. Reserved Attributes................................|TypeVim-reserved|

==============================================================================
INTRODUCTION                                                   *TypeVim-intro*

A library providing a crude, JavaScript-esque class system in vimscript.

vimscript allows users to assign Funcrefs into a dictionary; these functions,
if declared with the |[dict]| attribute, will be able to access and modify
their "owner" dictionary through a variable (`l:self`) accessible from within
their function body. This allows for object-oriented programming (OOP).

Unfortunately, vimscript does not provide for safe and convenient OOP. It
lacks inbuilt type checking (like what the TypeScript compiler might provide),
for instance. It also lacks explicit support for OOP features like
polymorphism.

TypeVim is meant to provide a sensible, standardized framework for "native"
object-oriented programming in vimscript.

==============================================================================
CONFIGURATION                                                 *TypeVim-config*

This plugin uses maktaba flags for configuration. Install Glaive
(https://github.com/google/glaive) and use the |:Glaive| command to configure
them.

                                                       *TypeVim:plugin[flags]*
Configures whether plugin/flags.vim should be loaded.
Default: 1 `

==============================================================================
DICTIONARIES                                                   *TypeVim-dicts*

                                                             *TypeVim.Promise*
A JavaScript-style Promise datatype for handling asynchronous operations.
|TypeVim.Promise| is meant to very roughly mimic JavaScript Promise objects in
usage and interface.

One notable departure from the JavaScript Promise interface is that
|TypeVim.Promise| tries to adhere to the Google VimScript style guide, so its
member functions are written in UpperCamelCase.

Because VimScript itself is entirely singlethreaded, Promise is only useful
when used with asynchronous operations, like asynchronous jobs and remote
procedure calls from neovim remote plugins.

typevim#Promise#New({Doer})                                    *Promise.New()*
  Return a new Promise that will be fulfilled (or broken) by a given {Doer}
  object.

  The {Doer} will be initialized (through a call to its `SetCallbacks` method)
  with two Funcrefs: as with JavaScript Promises, these are `Resolve` and
  `Reject`.

  The `Resolve` Funcref, when called by the {Doer}, will fulfill ("resolve")
  this Promise with the passed value (e.g. `Resolve("foo")` will pass `"foo"`
  to all attached success handlers).

  The (optional) `Reject` Funcref, when called, will break ("reject") this
  Promise with the passed value (e.g. `Reject("foo")` will pass `"foo"` to all
  attached error handlers).

  `Reject` is optional in that the `Doer.SetCallbacks` function may take
  either one Funcref as an argument (`Resolve`), or two (`Resolve` and
  `Reject`). |TypeVim.Promise| detects this automatically:
>
    " (pseudocode, not actual implementation)
    function! typevim#Promise#New(Doer) abort
      " ...
      try
        Doer.SetCallbacks(self.Resolve, self.Reject)
      catch TooManyArguments
        Doer.SetCallbacks(self.Resolve)
      endtry
      " ...
<

  Note that, unlike JavaScript, {Doer} is an actual object, rather than a
  function. This is meant for convenience; {Doer} is likely to have other
  member functions that it will pass (as callback functions) to, e.g. neovim's
  |jobstart()| function.

  Throws ERROR(BadValue) if {Doer}'s `SetCallbacks` function does not take
  either one argument or two arguments, or if {Doer} has no `SetCallbacks`
  function.
  Throws ERROR(WrongType) if {Doer} is not an object, or if
  `Doer.SetCallbacks` is not a Funcref.

Promise.Resolve({Val})                                     *Promise.Resolve()*
  Fulfill ("resolve") this Promise. Calls back all attached success handlers
  with the given {Val}, and updates the |Promise.State()| of this Promise to
  `"resolved"`.

  If the given {Val} is, itself, a |TypeVim.Promise|, then this Promise will
  "follow" that Promise, i.e. if {Val} resolves, then this Promise will
  resolve with the same value; if {Val} rejects, then this Promise will reject
  with the same value. Note that if {Val} returns ITSELF on resolution or
  rejection, then this function will infinitely recurse.

Promise.Reject({Val})                                       *Promise.Reject()*
  Break ("reject") this Promise. Calls back all attached error handlers with
  the given {Val}, and updates the |Promise.State()| of this Promise to
  `"rejected"`.

  If, in a previous call to |Promise.Then()|, this Promise was given a success
  handler without a matching error handler, then this Promise will (after
  calling back all attached error handlers) throw an ERROR(NotFound) exception
  due to the unhandled rejection.

  Note that, if a |TypeVim.Promise| is passed as {Val}, this function will not
  behave like |Promise.Resolve()|: it will not "wait" for {Val} to resolve or
  reject, but will start immediately calling back its error handlers with
  {Val} as its "reason".

  Throws ERROR(NotFound) if an attached success handler did not have a
  "matched"
  error handler.

Promise.Then({Resolve}, [Reject])                             *Promise.Then()*
  Attach a success handler {Resolve} and optionally an error handler [Reject]
  to this Promise. If this Promise resolves, it will call back {Resolve} with
  the resolved value. If it rejects, it will call back [Reject], or throw an
  ERROR(NotFound) exception due to an unhandled rejection if no [Reject]
  handler was attached.

  If this Promise is already resolved, it will call {Resolve} immediately with
  the resolved value. If it was already rejected, it will call [Reject]
  immediately, or throw an ERROR(NotFound) exception.

  It is strongly suggested that a [Reject] handler be provided in calls to
  this function.

  Throws ERROR(WrongType) if {Resolve} or [Reject] are not Funcrefs.

Promise.Catch({Reject})                                      *Promise.Catch()*
  Attach an error handler {Reject} to this Promise. If this Promise rejects,
  it will call back {Reject} with the provided value. If it was already
  rejected, it will call {Reject} immediately.

Promise.State()                                              *Promise.State()*
  Return the current state of this Promise: `"pending"`, `"resolved"`, or
  `"rejected"`.

==============================================================================
FUNCTIONS                                                  *TypeVim-functions*

typevim#ensure#IsValidTypename({typename})  *typevim#ensure#IsValidTypename()*
  Throws an ERROR(BadValue) if the given {typename} is not a valid typename,
  along with the reason it's not a valid typename; otherwise, does nothing.

  Returns the given {typename} for convenience.

  Throws ERROR(WrongType) if the given {typename} is not a string.

typevim#ensure#IsValidIdentifier({id})    *typevim#ensure#IsValidIdentifier()*
  Throws an ERROR(BadValue) if the given {id} is not a valid identifier, along
  with the reason it's not a valid identifier; otherwise, does nothing.

  Returns the given {id} for convenience.

  Throws ERROR(WrongType) if the given {id} is not a string.

typevim#ensure#IsValidObject({Val})           *typevim#ensure#IsValidObject()*
  Throws an ERROR(WrongType) if the given {Val} is not a valid TypeVim object.

  Returns {Val} for convenience.

typevim#ensure#IsType({Obj}, {typename})             *typevim#ensure#IsType()*
  Throws an ERROR(WrongType) if the given {Obj} is not an instance of the type
  {typename}.

  Returns {Obj} for convenience.

  Throws ERROR(WrongType) if {Obj} is not a dict or {typename} is not a
  string.

typevim#make#Class({typename}, {prototype}, [Destructor])
                                                        *typevim#make#Class()*
  Return a "typevim-configured" instance of a class. Meant to be called from
  inside a type's constructor, where it will take a {prototype} dictionary
  (containing member functions and member variables), annotate it with type
  information, and perform additional configuration (e.g. adding destructors).

  {typename} is the name of the type being declared.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might not be implemented.

  [Destructor] is an optional dictionary function that performs cleanup for
  the object.

  [Destructor] is 0 if omitted.
  Throws ERROR(BadValue) if the given {typename} is not a valid typename, see
  |typevim#value#IsValidTypename()|.
  Throws ERROR(NotAuthorized) if {prototype} defines attributes that should've
  been initialized by this function.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Derived({typename}, {Parent}, {prototype}, [Destructor],
  [clobber_base_vars])                                *typevim#make#Derived()*
  Return a "prototypical" instance of a type that inherits from another. Meant
  to be called from inside a type's constructor.

  {typename} is the name of the derived type being declared.

  {Parent} is either a Funcref to the base class constructor, or a base class
  prototype. If arguments must be passed to said constructor, in the former
  case, this should be a Partial.

  {prototype} is a dictionary object containing member variables (with default
  values) and member functions, which might be virtual. If the parent class
  defines functions with the same name (i.e. same dictionary key), they will
  be overridden with those of the {prototype}.

  [Destructor] is an optional dictionary function that performs cleanup for
  the object. On destruction, defined destructors will be called in reverse
  order, i.e.  the "most derived" destructor will be called first, with the
  "original" base class destructor being called last.

  [clobber_base_vars] is a boolean flag that, if true, will allow member
  variables of the base class to be overwritten by member variables of the
  derived class being declared. This is discouraged, since direct access and
  modification of base class member variables is generally considered bad
  style.

  [clobber_base_vars] is 0 if omitted.

  Throws ERROR(BadValue) if {typename} is not a valid typename.
  Throws ERROR(NotAuthorized) when the given {prototype} would redeclare a
  non-Funcref member variable of the base class, and [clobber_base_vars] is
  not 1.
  Throws ERROR(WrongType) if arguments don't have the types named above.

typevim#make#Member({funcname})                        *typevim#make#Member()*
  Return a Funcref to the function with the name constructed by concatenating
  the following: (1) the "autoload prefix" from which this function was called
  (e.g. if called from `~/.vim/bundle/myplugin/autoload/myplugin/foo.vim` the
  prefix would be "myplugin#foo#"); (2) the given {funcname}.

  This is meant as a convenience function to reduce boilerplate when declaring
  TypeVim objects. Instead of long, explicit assignments like,
>
    " ~/.vim/bundle/myplugin/autoload
    function! myplugin#subdirectory#LongClassName##New() abort
      " ...
      let l:new = {
        " ...
        \ 'DoAThing':
      function('myplugin#subdirectory#LongClassName##DoAThing'),
      " ...
      return typevim#make#Class(l:new)
    endfunction

    function! myplugin#subdirectory#LongClassName##DoAThing() dict abort
      " ...
<

  One can instead write,
>
      " ...
      let l:new = {
        " ...
        \ 'DoAThing': typevim#make#Member('DoAThing'),
      " ...
<

  Which is functionally equivalent.

typevim#object#Bind({Funcref}, {obj}, [arglist], [argslist], [force_rebind])
                                                       *typevim#object#Bind()*
  Returns a Partial consisting of the given {Funcref} that is bound to this
  particular {obj} and to [arglist], i.e. return `funcref(a:Funcref,
  a:arglist, a:obj)`.

  If the member function is already bound to an argslist, then [argslist] will
  be appended to the function's current argslist.

  If the {Funcref} function is already bound to a dict, throws an
  ERROR(NotAuthorized) exception unless the dict and {obj} are the same
  object; however, if [force_rebind] is 1, the bound dict will be replaced
  with the given {obj}.

  This function is comparable to the `bind()` method on class member functions
  in JavaScript, and to the `std::bind()` function in the C++ standard
  library. Its primary purpose is to extract a "self-contained" class member
  Funcref that "remembers" its original `l:self`, even when it is assigned
  into another object. (This is done frequently in asynchronous event-based
  programming when passing callback functions.)

  See `:help Partial` for an explanation of why it would be bad not to do
  this. (In short, when a "non-bound" Funcref is assigned into another object,
  then when that object calls it, every `l:self` variable in the Funcref's
  definition will point to the NEW object, and NOT to the Funcref's original
  `l:self`; that invocation will then modify that new object as if it were the
  original `l:self`, even if it's of a different class entirely.)

  Note that argument parameters affect the RETURNED Funcref, NOT the Funcref
  that is given as an argument.
>
    " does NOT change obj.Method
    call typevim#object#Bind(obj.Method, diff_obj)

    " DOES change obj.Method
    let obj.Method = typevim#object#Bind(obj.Method, diff_obj)
<

  Throws ERROR(NotAuthorized) if {Funcref} is already bound to a dict that is
  not {obj} and [force_rebind] is 0.
  Throws ERROR(WrongType) if {obj} is not a TypeVim object, or if {Funcref} is
  not a Funcref, or if [arglist] is not a list.

typevim#object#AbstractFunc({typename}, {funcname}, {parameters})
                                               *typevim#object#AbstractFunc()*
  Returns a Partial, assignable into an object with type {typename}, standing
  in for a function named {funcname}, that takes in arguments with the names
  given in {parameters}.

  To specify optional parameters, enclose the parameter name in square
  brackets. To specify that a variable number of arguments are acceptable,
  write "...".

  Example invocation:
>
    let l:new['PureVirtualFunc'] = typevim#object#Virtual(
          \ 'ExampleObject`, 'exampleMethod', '['arg1', '[optional1]', '...'])
<

  An argument list, if specified, must come after all other parameters named.
  Optional parameters, if specified, must come after all non-optional
  parameters, if any.

  Parameters names must be strings and cannot be empty strings, and must be
  valid identifiers (see |typevim#value#IsValidIdentifier()|). They must also
  be unique.

  The returned function, when invoked, will throw ERROR(InvalidArguments) if
  given the wrong number of arguments (and if Vim itself doesn't throw an
  "|E116|: Invalid arguments for function" exception or an "|E119|: Not enough
  arguments for function" exception).

  If the number of arguments is correct, the returned function will throw an
  exception saying that it is an unimplemented virtual function
  Throws ERROR(BadValue) if {parameters} does not adhere to the requirements
  above; or if {typename} s not a valid typename; or if {funcname} is not a
  valid identifier.
  Throws ERROR(WrongType) if {typename} isn't a string or {parameters} isn't a
  list of strings.

typevim#object#PrettyPrint({object})            *typevim#object#PrettyPrint()*
  Converts the given {object} into a string, suitable for error messages and
  debug logging.

  If it's already a string, encloses the string in quotes (useful when a
  string is purely whitespace). If it's a TypeVim object or a dictionary, adds
  newlines and tabs to make the resulting string human-readable.

typevim#object#ShallowPrint({Obj}, [max_depth])
                                               *typevim#object#ShallowPrint()*
  Like |typevim#object#PrettyPrint()|, but will recurse at most [max_depth]
  levels down into {Obj} if it's a collection or a Partial.

  [max_depth] is 1 if omitted.
  Throws ERROR(BadValue) if [max_depth] is negative.
  Throws ERROR(WrongType) if [max_depth] is not a number.

typevim#value#IsValidTypename({typename})    *typevim#value#IsValidTypename()*
  Returns 1 when the given {typename} is valid, 0 otherwise.

  A valid typename is a string of uppercase Latin letters, lowercase Latin
  letters, numbers, and underscores. It must start with a capital letter, and
  cannot contain "unusual" characters, e.g. accented Latin letters, emoji,
  etc.

  {typename} cannot be an empty string, nor can it be a "reserved attribute".
  See |TypeVim-reserved| for more details.

typevim#value#IsValidIdentifier({id})      *typevim#value#IsValidIdentifier()*
  Returns 1 when the given {id} is a a valid identifier, 0 otherwise.

  A valid identifier must meet the same requirements as a valid typename (see
  |typevim#value#IsValidTypename()|), but can start with either a lowercase or
  uppercase letter.

typevim#value#IsValidObject({Val})             *typevim#value#IsValidObject()*
  Returns 1 when the given object is a valid TypeVim object, 0 otherwise.

  A valid TypeVim object is a dictionary; it contains a `'TYPE'` entry, also a
  dictionary, whose keys are typenames (see |IsValidTypename()|) and whose
  values can be anything, though it is suggested that they be an arbitrary
  number (typically `1`).

typevim#value#IsType({Obj}, {typename})               *typevim#value#IsType()*
  Returns 1 when the given {Obj} is an instance of the type {typename}, and 0
  otherwise.

  Throws ERROR(BadValue) if {typename} isn't a valid typename, or if {Obj} is
  not a TypeVim object.
  Throws ERROR(WrongType) if {Obj} is not a dict, or if {typename} isn't a
  string.

typevim#value#IsPartial({Obj})                     *typevim#value#IsPartial()*
  Returns 1 when the given object is a Partial (see `:help Partial`) and 0
  otherwise.

typevim#value#DecomposePartial({Func})      *typevim#value#DecomposePartial()*
  If the Funcref {Func} is a Partial, decomposes {Func} into a four-element
  list containing: first, the function name; second, the Funcref itself;
  third, the bound arguments; and fourth, the bound dictionary. The latter two
  elements can be empty if {Func} is not bound to arguments or a dictionary,
  respectively.

  Throws ERROR(WrongType) if {Func} is not a Funcref.

typevim#value#GetStackFrame({num_levels_down}, [funcname])
                                               *typevim#value#GetStackFrame()*
  When invoked from a namespaced autoload function, return the name of the
  function {num_levels_down} the callstack, e.g. if called with
  {num_levels_down} = 2, get the callstack (as as string), strip this function
  from its top, then strip the function that called this function from its
  top, and then return the topmost function remaining

  If [funcname] is provided, it will be prefixed with `"#"` and appended to
  the returned string.

  Example inputs and outputs:
>
    function! Foo() abort
    " current callstack: function MainFunc[2]..<SNR>215_ScriptFunc[1]..Foo

    " echoes 'Foo', the name of the calling function
    echo typevim#value#GetStackFrame(0)

    " echoes '<SNR>215_ScriptFunc'
    echo typevim#value#GetStackFrame(1)

    " echoes 'MainFunc'
    echo typevim#value#GetStackFrame(2)

    " ERROR(NotFound)
    echo typevim#value#GetStackFrame(3)
<
  endfunction <

  [funcname] is "" if omitted.
  Throws ERROR(NotFound) if there is no stack frame {num_levels_down}.
  Throws ERROR(WrongType) if {num_levels_down} is not a number or [funcname]
  is not a string.

==============================================================================
CLASS DEFINITIONS                                               *TypeVim-make*

TypeVim offers helper functions for defining new object types. These are meant
to be invoked from within an object's constructor.

==============================================================================
DECLARING A CLASS                                         *TypeVim-basic_decl*

In general, to declare a new class, one should:

First, create a "namespaced" *.vim file for this class, i.e. a file in:
>
  myplugin/  # plugin root dir
    autoload/
      myplugin/  # autoload subdirectory; name matters
        ExampleClass.vim
<
Unless you have a good reason not to, all of `ExampleClass`'s relevant
functions should be declared in `ExampleClass.vim`. This has the benefit of
placing all of `ExampleClass`'s function definitions in an appropriate
"namespace": based on vim's naming rules for autoload scripts (see `:help
autoload`), a function in `ExampleClass.vim` named `Foo()` will be invocable
through `:call myplugin#ExampleClass#Foo()`."

Second, declare a class constructor. By convention, a class constructor should
be named `New`, e.g. `myplugin#ExampleClass#New()`. It may have any number of
arguments.

Third, inside the constructor, construct a class "prototype." This is a
dictionary object initialized with your class's member variables and functions
(sometimes called "class properties," like in JavaScript):
>
  " in myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#New(num1, str2, ...) abort
    " type checking (with vim-maktaba) not required, but strongly encouraged
    call maktaba#ensure#IsNumber(a:num1)
    call maktaba#ensure#IsString(a:str2)

    " optional parameter with a default value of 3.14
    let a:optional_float = maktaba#ensure#IsFloat(get(a:000, 0, 3.14))

    let l:example_prototype = {
        \ '_single_underscore': a:num1,
        \ '_implies_var_is_private': a:str2,
        \ '__double_underscore': a:optional_float,
        \ '__means_definitely_private': 42,
        \ 'PublicFunction':
            \ typevim#PrefixFunc('PublicFunction'),
        \ '__PrivateFunction':
            \ typevim#PrefixFunc('__PrivateFunction'),
        \ }

    return typevim#make#Class(l:example_prototype)
  endfunction
<

Fourth, implement the rest of the class. In the example given, we referred to
a `PublicFunction()` and a `__PrivateFunction()`, so we implement both here:
>
  " still myplugin/autoload/myplugin/ExampleClass.vim
  function! myplugin#ExampleClass#PublicFunction() dict abort
    " NOTE: `dict` keyword is necessary to have access to l:self variable
    echo 'Hello, World! My number is: ' . l:self['_single_underscore']
  endfunction

  function! myplugin#ExampleClass#__PrivateFunction() dict abort
    " ...
  endfunction
<
Note how the functions are named. In step (3), the calls to
|typevim#PrefixFunc()| return Funcrefs equivalent to
`function('myplugin#ExampleClass#PublicFunction')` and
`function('myplugin#ExampleClass#__PrivateFunction')`, respectively. See
`:help function()` and `:help Funcref` for more details on what this means.

You can see that the full `function('...')` expression is very verbose;
`object#PrefixFunc()` is a helper function to help eliminate that boilerplate.

Finally, test your class, or just start using it!
>
  let ex_1 = myplugin#ExampleObject#new(1, 'foo')
  let ex_2 = myplugin#ExampleObject#new(2, 'boo', 6.28)

  call ex_1.PublicFunction()  " echoes 'Hello, World! My number is: 1'
  call ex_2.PublicFunction()  " echoes 'Hello, World! My number is: 2'
<

==============================================================================
DECLARING A DERIVED CLASS (POLYMORPHISM)                   *TypeVim-poly_decl*


TODO

==============================================================================
RESERVED ATTRIBUTES                                         *TypeVim-reserved*


Reserved attributes are properties of TypeVim objects that are "reserved" by
TypeVim for "bookkeeping." These include the attributes used for tracking an
object's dynamic type, its class hierarchy, its order of destructor calls, and
so on.

Users shall not modify these properties, as doing so will lead to undefined
behavior. Attempting to explicitly set the values of these attributes (e.g. in
a class constructor) will sometimes cause TypeVim to throw
ERROR(NotAuthorized) exceptions.

In general, the names of these attributes are fully capitalized and enclosed
in triple-underscores (e.g. `"___TYPE___"`), roughly similar to how Python
names its "dunder methods" (e.g. `"__main__", "__call__"`). Declaring class
members with names that use this format (e.g. declaring an object with a
`"___SIZE___"` property) is strongly discouraged, though not disallowed.

Typenames and identifiers shall not share the name of a reserved attribute.


vim:tw=78:ts=8:ft=help:norl:

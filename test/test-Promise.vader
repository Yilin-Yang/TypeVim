Execute (typevim#Promise: Set Up):
  let g:Val = ''
  function! SetVal(Val) abort
    let g:Val = a:Val
    return a:Val
  endfunction

  function! GetValAndReset() abort
    let l:to_return = g:Val
    let g:Val = ''
    return l:to_return
  endfunction

  let g:Other = ''
  function! SetOther(Val) abort
    let g:Other = a:Val
    return a:Val
  endfunction

  function! GetOtherAndReset() abort
    let l:to_return = g:Other
    let g:Other = ''
    return l:to_return
  endfunction

  let g:Val2 = ''
  function! SetVal2(Val) abort
    let g:Val2 = a:Val
    return a:Val
  endfunction

  function! GetVal2AndReset() abort
    let l:to_return = g:Val2
    let g:Val2 = ''
    return l:to_return
  endfunction

  let g:Other2 = ''
  function! SetOther2(Val) abort
    let g:Other2 = a:Val
    return a:Val
  endfunction

  function! GetOther2AndReset() abort
    let l:to_return = g:Other2
    let g:Other2 = ''
    return l:to_return
  endfunction

  function! ThrowAsException(Val) abort
    throw 'except: '.string(a:Val)
  endfunction

  function! ValPlusOne(Val) abort
    return a:Val + 1
  endfunction

  function! ReturnZero(...) abort
    return 0
  endfunction

Execute (typevim#Promise: Immediate Fulfillment):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'))
  call g:promise.Resolve('resolve')
  AssertEqual 'resolve', GetValAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'fulfilled', g:promise.State()
Then (Test Error Handling, Post Resolution Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already fulfilled Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()
  AssertEqual 'fulfilled', g:promise.State()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already fulfilled Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'fulfilled', g:promise.State()

Execute (typevim#Promise: State Progression):
  let g:promise = typevim#Promise#New()
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()

  call g:promise.Then(function('SetVal'))
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()

  call g:promise.Resolve('fulfilled')
  AssertEqual 'fulfilled', g:promise.State()

  let g:promise = typevim#Promise#New()

  call g:promise.Then(function('SetVal'), function('SetOther'))
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()

  call g:promise.Reject('rejected')
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Immediate Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:promise.Reject('reject')
  AssertEqual 'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()
Then (Test Error Handling, Post Rejection Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetOtherAndReset()

Execute (typevim#Promise: Attach Handlers to Already Resolved):
  let g:promise = typevim#Promise#New()
  call g:promise.Resolve('resolve')
  call g:promise.Then(function('SetVal'), function('SetOther'))
  AssertEqual 'resolve', GetValAndReset()
  AssertNotEqual 'resolve', GetOtherAndReset()

Execute (typevim#Promise: Attach Handlers to Already Rejected):
  let g:promise = typevim#Promise#New()
  AssertThrows call g:promise.Reject('reject')
  call g:promise.Then(function('SetVal'), function('SetOther'))
  AssertNotEqual 'reject', GetValAndReset()
  AssertEqual 'reject', GetOtherAndReset()

Execute (typevim#Promise: Resolution w/out Success Handlers):
  let g:promise = typevim#Promise#New()
  call g:promise.Catch(function('SetOther'))
  call g:promise.Resolve('foo')
  AssertEqual '', GetValAndReset()

Execute (typevim#Promise: Resolve Next-in-Chain w/out Success Handler):
  let g:promise = typevim#Promise#New()
  let g:last_link = g:promise.Catch(function('SetOther'))
  call g:promise.Resolve('foo')
  AssertEqual '', GetValAndReset()

  " last_link should still resolve with an 'unmodified' value of 'foo'
  AssertEqual 'foo', g:last_link.Get()
  AssertEqual 'fulfilled', g:last_link.State()

Execute (typevim#Promise: Resolve/Reject Next-in-Chain, Non Funcref Arguments):
  let g:to_resolve = typevim#Promise#New()
  let g:resolved = g:to_resolve.Then(0, 1)

  let g:to_reject = typevim#Promise#New()
  let g:rejected = g:to_reject.Then(0, 1)

  call g:to_resolve.Resolve('foo')
  AssertThrows call g:to_reject.Reject('foo')

  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'foo'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'foo', g:rejected.Get()
  AssertEqual 'rejected', g:rejected.State()

  " last_link should still resolve with an 'unmodified' value of 'foo'
  AssertEqual 'foo', g:resolved.Get()
  AssertEqual 'fulfilled', g:resolved.State()

Execute (typevim#Promise: Resolve with Pending Promise):
  let g:doer = MockDoer#New()
  let g:x = typevim#Promise#New(g:doer)
  let g:promise =  typevim#Promise#New()
  call g:promise.Resolve(g:x)
  AssertEqual 'pending', g:promise.State()
  call g:doer.Resolve('yes')
  AssertEqual 'fulfilled', g:promise.State()
  AssertEqual 'yes', g:promise.Get()

Execute (typevim#Promise: Reject with Pending Promise):
  let g:doer = MockDoer#New()
  let g:x = typevim#Promise#New(g:doer)
  let g:promise =  typevim#Promise#New()
  call g:promise.Resolve(g:x)
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:doer.Reject('no')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'no'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'rejected', g:promise.State()
  AssertEqual 'no', g:promise.Get()

Execute (typevim#Promise: Resolve with Pending Promise, and Old Doer Resolves):
  let g:doer = MockDoer#New()
  let g:x = typevim#Promise#New(g:doer)
  let g:old_doer = MockDoer#New()
  let g:promise =  typevim#Promise#New(g:old_doer)

  " g:promise is now 'bound' to the state of g:x
  call g:promise.Resolve(g:x)

  " resolution of 'old' Doer should not affect this Promise's state
  call g:old_doer.Resolve('ja')
  AssertEqual 'pending', g:promise.State()

  call g:doer.Resolve('yes')
  AssertEqual 'fulfilled', g:promise.State()
  AssertEqual 'yes', g:promise.Get()

Execute (typevim#Promise: Resolve with Resolved Promise):
  let g:doer = MockDoer#New()
  let g:x = typevim#Promise#New(g:doer)
  let g:promise = typevim#Promise#New()
  call g:doer.Resolve('yes')
  call g:promise.Resolve(g:x)
  AssertEqual 'fulfilled', g:promise.State()
  AssertEqual 'yes', g:promise.Get()

Execute (typevim#Promise: Resolve with Rejected Promise):
  let g:doer = MockDoer#New()
  let g:x = typevim#Promise#New(g:doer)

  " silently 'pre-reject' this Promise
  call g:x.Catch(function('ReturnZero'))
  call g:doer.Reject('no')

  let g:promise =  typevim#Promise#New()
  AssertThrows call g:promise.Resolve(g:x)
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'no'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'rejected', g:promise.State()
  AssertEqual 'no', g:promise.Get()

Execute (typevim#Promise: Resolve Promise with Itself):
  let g:promise = typevim#Promise#New()
  AssertThrows call g:promise.Resolve(g:promise)
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(BadValue): Tried to resolve a Promise with itself: '),
      \ 'Threw wrong exception: '.g:vader_exception

Execute (typevim#Promise: Rejection w/ Catch Handler):
  let g:promise = typevim#Promise#New()
  let g:result = g:promise.Catch(function('SetOther'))
  call g:promise.Reject('reject')
  AssertEqual 'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()
  AssertEqual 'fulfilled', g:result.State()

Execute (typevim#Promise: Throw Exception from Success Handler):
  let g:promise = typevim#Promise#New()
  let g:last_link = g:promise.Then(function('ThrowAsException'))
  AssertThrows call g:promise.Resolve('foo')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'except: ''foo'''"),
      \ 'Threw wrong exception: '.g:vader_exception

  " g:promise is resolved by the call to Resolve
  AssertEqual "foo", g:promise.Get()
  AssertEqual 'fulfilled', g:promise.State()

  " but, ThrowAsException throws an exception, which rejects last_link,
  " and last_link throws an exception due to the unhandled rejection
  AssertEqual "except: 'foo'", g:last_link.Get()
  AssertEqual 'rejected', g:last_link.State()

Execute (typevim#Promise: Throw Exception from Error Handler):
  let g:promise = typevim#Promise#New()
  let g:last_link = g:promise.Catch(function('ThrowAsException'))
  AssertThrows call g:promise.Reject('foo')

  " g:promise is rejected by the call to Reject, with 'foo' as its reason
  AssertEqual 'foo', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

  " g:last_link is also rejected, since g:promise's error handler threw an
  " exception
  AssertEqual "except: 'foo'", g:last_link.Get()
  AssertEqual 'rejected', g:last_link.State()

Execute (typevim#Promise: Unhandled Promise Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'))
  AssertThrows call g:promise.Reject('reject')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'reject'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Resolution by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Resolve('resolve')
  AssertEqual    'resolve', GetValAndReset()
  AssertNotEqual 'resolve', GetOtherAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'fulfilled', g:promise.State()

Execute (typevim#Promise: Rejection by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Reject('reject')
  AssertNotEqual 'reject', GetValAndReset()
  AssertEqual    'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Test Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:next_link = g:promise.Then(function('ValPlusOne'), function('SetOther'))
  call g:doer.Resolve(0)
  AssertEqual 1, g:next_link.Get()

Execute (typevim#Promise: Test Deep Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('ValPlusOne'), function('SetVal'))
      \.Then(function('ValPlusOne'), function('SetOther'))
  call g:doer.Resolve(0)
  AssertEqual 2, g:last_link.Get()
  AssertEqual 'fulfilled', g:last_link.State()

Execute (typevim#Promise: Unhandled Rejection at End of Chain):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('ValPlusOne'))
      \.Then(function('ValPlusOne'))
      \.Then(function('SetVal'))
  AssertThrows call g:doer.Reject('rejected')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'rejected'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'rejected', g:last_link.Get()
  AssertEqual 'rejected', g:last_link.State()
  AssertNotEqual 'rejected', GetValAndReset()

Execute (typevim#Promise: Storage of Final Rejected Value in Chain):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'), function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'reject', g:last_link.Get()
  AssertEqual 'fulfilled', g:last_link.State()

Execute (typevim#Promise: Rejection Handling w/ Chain of Then):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'), function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'fulfilled', g:last_link.State()

  AssertEqual 'reject', GetOtherAndReset()
  AssertNotEqual 'reject', GetValAndReset()

Execute (typevim#Promise: Rejection Handling w/ Then, Terminate with Catch):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Catch(function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'fulfilled', g:last_link.State()

  AssertEqual 'reject', GetOtherAndReset()
  AssertNotEqual 'reject', GetValAndReset()

Execute (typevim#Promise: "Interception" of Unhandled Rejection):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_rejected =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'))
  let g:last_link =
      \ g:last_rejected
      \.Catch(function('SetOther'))
      \.Then(function('SetVal2'))
      \.Then(function('SetVal2'))
      \.Then(function('SetVal2'), function('SetOther2'))

  call g:doer.Reject('reject')
  AssertEqual 'rejected', g:promise.State()
  AssertEqual 'rejected', g:last_rejected.State()
  AssertEqual 'fulfilled', g:last_link.State()

  AssertEqual 'reject', GetOtherAndReset()
  AssertNotEqual 'reject', GetValAndReset()
  AssertEqual 'reject', GetVal2AndReset()
  AssertNotEqual 'reject', GetOther2AndReset()

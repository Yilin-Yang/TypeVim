Execute (typevim#Promise: Set Up):
  let g:Val = ''
  function! SetVal(Val) abort
    let g:Val = a:Val
    return a:Val
  endfunction

  function! GetValAndReset() abort
    let l:to_return = g:Val
    let g:Val = ''
    return l:to_return
  endfunction

  let g:Other = ''
  function! SetOther(Val) abort
    let g:Other = a:Val
    return a:Val
  endfunction

  function! GetOtherAndReset() abort
    let l:to_return = g:Other
    let g:Other = ''
    return l:to_return
  endfunction

Execute (typevim#Promise: Immediate Fulfillment):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'))
  call g:promise.Resolve('resolve')
  AssertEqual 'resolve', GetValAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'resolved', g:promise.State()
Then (Test Error Handling, Post Resolution Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already resolved Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already resolved Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception

Execute (typevim#Promise: State Progression):
  let g:promise = typevim#Promise#New()
  AssertEqual 'pending', g:promise.State()
  AssertEqual 0, g:promise._HadHandlers()
  AssertThrows call g:promise.Get()

  call g:promise.Then(function('SetVal'))
  AssertEqual 'pending', g:promise.State()
  AssertEqual 1, g:promise._HadHandlers()
  AssertThrows call g:promise.Get()

  call g:promise.Resolve('resolved')
  AssertEqual 'resolved', g:promise.State()
  AssertEqual 1, g:promise._HadHandlers()

  let g:promise = typevim#Promise#New()
  AssertEqual 0, g:promise._HadHandlers()
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()

  call g:promise.Then(function('SetVal'), function('SetOther'))
  AssertEqual 1, g:promise._HadHandlers()
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()

  call g:promise.Reject('rejected')
  AssertEqual 'rejected', g:promise.State()
  AssertEqual 1, g:promise._HadHandlers()

Execute (typevim#Promise: Immediate Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:promise.Reject('reject')
  AssertEqual 'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()
Then (Test Error Handling, Post Rejection Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetOtherAndReset()

Execute (typevim#Promise: Resolution w/out Success Handlers):
  let g:promise = typevim#Promise#New()
  call g:promise.Catch(function('SetOther'))
  call g:promise.Resolve('foo')
  AssertEqual '', GetValAndReset()

Execute (typevim#Promise: Rejection w/ Catch Handler):
  let g:promise = typevim#Promise#New()
  call g:promise.Catch(function('SetOther'))
  call g:promise.Reject('reject')
  AssertEqual 'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Unhandled Promise Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'))
  AssertThrows call g:promise.Reject('reject')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'reject'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Resolution by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Resolve('resolve')
  AssertEqual    'resolve', GetValAndReset()
  AssertNotEqual 'resolve', GetOtherAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'resolved', g:promise.State()

Execute (typevim#Promise: Rejection by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Reject('reject')
  AssertNotEqual 'reject', GetValAndReset()
  AssertEqual    'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Test Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:next_link = g:promise.Then({ val -> val + 1}, function('SetOther'))
  call g:doer.Resolve(0)
  AssertEqual 1, g:next_link.Get()

Execute (typevim#Promise: Test Deep Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then({ val -> val + 1}, function('SetVal'))
      \.Then({ val -> val + 1 }, function('SetOther'))
  call g:doer.Resolve(0)
  AssertEqual 2, g:last_link.Get()
  AssertEqual 'resolved', g:last_link.State()

Execute (typevim#Promise: Unhandled Rejection at End of Chain):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then({ val -> val + 1})
      \.Then({ val -> val + 1 })
      \.Then(function('SetVal'))
  AssertThrows call g:doer.Reject('rejected')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'rejected'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'rejected', g:last_link.Get()
  AssertEqual 'rejected', g:last_link.State()
  AssertNotEqual 'rejected', GetValAndReset()

Execute (typevim#Promise: Storage of Final Rejected Value in Chain):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'), function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'reject', g:last_link.Get()

Execute (typevim#Promise: Rejection Handling w/ Chain of Then):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'), function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'rejected', g:last_link.State()

  AssertEqual 'reject', GetOtherAndReset()
  AssertNotEqual 'reject', GetValAndReset()

Execute (typevim#Promise: Rejection Handling w/ Then, Terminate with Catch):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Then(function('SetVal'))
      \.Catch(function('SetOther'))

  call g:doer.Reject('reject')
  AssertEqual 'rejected', g:last_link.State()

  AssertEqual 'reject', GetOtherAndReset()
  AssertNotEqual 'reject', GetValAndReset()

Execute (typevim#Promise: Set Up):
  let g:Val = ''
  function! SetVal(Val) abort
    let g:Val = a:Val
  endfunction

  function! GetValAndReset() abort
    let l:to_return = g:Val
    let g:Val = ''
    return l:to_return
  endfunction

  let g:Other = ''
  function! SetOther(Val) abort
    let g:Other = a:Val
  endfunction

  function! GetOtherAndReset() abort
    let l:to_return = g:Other
    let g:Other = ''
    return l:to_return
  endfunction

Execute (typevim#Promise: Immediate Fulfillment):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'))
  call g:promise.Resolve('resolve')
  AssertEqual 'resolve', GetValAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'resolved', g:promise.State()
Then (Test Error Handling, Post Resolution Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already resolved Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already resolved Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception

Execute (typevim#Promise: State Progression):
  let g:promise = typevim#Promise#New()
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()
  call g:promise.Then(function('SetVal'))
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()
  call g:promise.Resolve('resolved')
  AssertEqual 'resolved', g:promise.State()

  let g:promise = typevim#Promise#New()
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()
  call g:promise.Then(function('SetVal'), function('SetOther'))
  AssertEqual 'pending', g:promise.State()
  AssertThrows call g:promise.Get()
  call g:promise.Reject('rejected')
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Immediate Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:promise.Reject('reject')
  AssertEqual 'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()
Then (Test Error Handling, Post Rejection Resolve/Reject):
  AssertThrows call g:promise.Resolve('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to resolve an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetValAndReset()

  AssertThrows call g:promise.Reject('another')
  AssertNotEqual -1, match(g:vader_exception,
      \ 'ERROR(NotAuthorized): Tried to reject an already rejected Promise: '),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertNotEqual 'another', GetOtherAndReset()

Execute (typevim#Promise: Unhandled Promise Rejection):
  let g:promise = typevim#Promise#New()
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:promise.Then(function('SetVal'))
  AssertThrows call g:promise.Reject('reject')
  AssertNotEqual -1, match(g:vader_exception,
      \ "ERROR(NotFound): Unhandled Promise rejection; rejected with reason: 'reject'"),
      \ 'Threw wrong exception: '.g:vader_exception
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Resolution by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Resolve('resolve')
  AssertEqual    'resolve', GetValAndReset()
  AssertNotEqual 'resolve', GetOtherAndReset()
  AssertEqual 'resolve', g:promise.Get()
  AssertEqual 'resolved', g:promise.State()

Execute (typevim#Promise: Rejection by Doer):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  call g:promise.Then(function('SetVal'), function('SetOther'))
  call g:doer.Reject('reject')
  AssertNotEqual 'reject', GetValAndReset()
  AssertEqual    'reject', GetOtherAndReset()
  AssertEqual 'reject', g:promise.Get()
  AssertEqual 'rejected', g:promise.State()

Execute (typevim#Promise: Set Up for Test Chaining):
  function! SetVal2(Val) abort
    let g:val2 = a:Val
  endfunction

  function! GetVal2AndReset() abort
    let l:to_return = g:Val2
    let g:Val2 = ''
    return l:to_return
  endfunction

  function! SetOther2(Val) abort
    let g:other2 = a:Val
  endfunction

  function! GetOther2AndReset() abort
    let l:to_return = g:Other2
    let g:other2 = ''
    return l:to_return
  endfunction

Execute (typevim#Promise: Test Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:next_link = g:promise.Then({ val -> val + 1})
  call g:doer.Resolve(0)
  AssertEqual 1, g:next_link.Get()

Execute (typevim#Promise: Test Deep Promise Chaining):
  let g:doer = MockDoer#New()
  let g:promise = typevim#Promise#New(g:doer)
  let g:last_link =
      \ g:promise.Then({ val -> val + 1})
      \.Then({ val -> val + 1 }, function('SetOther'))
  call g:doer.Resolve(0)
  AssertEqual 2, g:last_link.Get()
  AssertEqual 'resolved', g:last_link.State()

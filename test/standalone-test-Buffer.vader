Include: AssertThrew.vader

Execute (Buffer: Construct Default):
  let g:buffer = typevim#Buffer#New()
  call g:buffer.Open()
Then:
  AssertEqual 'hide',   &bufhidden
  AssertEqual 0,        &buflisted
  AssertEqual 'nofile', &buftype
  AssertEqual 0,        &swapfile

Execute (Buffer: Set Buffer Variable):
  let g:buffer = typevim#Buffer#New()
  call g:buffer.setbufvar('test_var', 1)
  call g:buffer.Open()
Then:
  AssertEqual 1, b:test_var

Execute (Buffer: Get Buffer Variable):
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')
  AssertEqual 1, g:buffer.getbufvar('test_var')

Execute (Buffer: Exchange):
  AssertEqual 1, g:buffer.getbufvar('&modifiable')
  let g:old_vals = g:buffer.ExchangeBufVars({'&modifiable': 0, '&buftype': '', 'test_var': ''})

  AssertEqual 0, g:buffer.getbufvar('&modifiable')
  AssertEqual '', g:buffer.getbufvar('&buftype')
  AssertEqual '', g:buffer.getbufvar('test_var')

  let g:new_vals = g:buffer.ExchangeBufVars(g:old_vals)

  AssertEqual 1,        g:buffer.getbufvar('&modifiable')
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')
  AssertEqual 1,        g:buffer.getbufvar('test_var')

Execute (Buffer: SetDoRestore Works and Returns Value When Given Funcref):
  function! Foo() abort
    return 42
  endfunction
  AssertEqual 42, g:buffer.SetDoRestore({'&buftype': ''}, function('Foo'))
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')

Execute (Buffer: SetDoRestore Restores Variables on BadValue Exception):
  function! Foo(unused_var) abort
    return 42
  endfunction
  AssertThrows call g:buffer.SetDoRestore({'&buftype': ''}, function('Foo'))
  AssertThrew 'ERROR(BadValue)'
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')

Execute (Buffer: SetDoRestore Restores Variables on Other Exception):
  function! Foo() abort
    throw 'AAAAAA'
  endfunction
  AssertThrows call g:buffer.SetDoRestore({'&buftype': ''}, function('Foo'))
  AssertThrew 'AAAAAA'
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')

Execute (Buffer: SetDoRestore Works When Executing Command):
  AssertEqual 0, g:buffer.SetDoRestore({'&buftype': ''}, 'let g:foo = "bar" | let g:bar = "foo"')
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')
  AssertEqual 'bar', g:foo
  AssertEqual 'foo', g:bar
  unlet g:foo
  unlet g:bar

Execute (Buffer: SetDoRestore Restores When Given Command Throws Exception):
  AssertThrows call g:buffer.SetDoRestore({'&buftype': ''}, 'throw "AAAAAA"')
  AssertThrew "AAAAAA"
  AssertEqual 'nofile', g:buffer.getbufvar('&buftype')

Execute (Buffer: Declare Helpers for Checking Before-and-After):
  function! SaveState() abort
    set nolazyredraw
    let l:tabpage = tabpagenr()
    let l:winview = winsaveview()
    return [l:tabpage, l:winview]
  endfunction

  function! AssertSameState(tabp_and_winview) abort
    call maktaba#ensure#IsList(a:tabp_and_winview)
    AssertEqual 0, &lazyredraw
    AssertEqual a:tabp_and_winview[0], tabpagenr()
    AssertEqual a:tabp_and_winview[1], winsaveview()
  endfunction

Execute (Buffer: OpenDoRestore Works and Returns Value When Given Funcref):
  function! Foo() abort
    let b:foobar = 1
    return 42
  endfunction

  let g:state = SaveState()
  AssertEqual 42, g:buffer.OpenDoRestore(function('Foo'))
  AssertEqual 1, g:buffer.getbufvar('foobar')
  call AssertSameState(g:state)

Execute (Buffer: OpenDoRestore Works When Given Evaltext):
  let g:state = SaveState()
  AssertEqual 0, g:buffer.OpenDoRestore('let b:barfoo = 2 | let b:goofar = 3')
  AssertEqual 2, g:buffer.getbufvar('barfoo')
  AssertEqual 3, g:buffer.getbufvar('goofar')
  call AssertSameState(g:state)

Execute (Buffer: OpenDoRestore Restores Everything On Funcref BadValue):
  function! Foo(unused) abort
    return 42
  endfunction

  let g:state = SaveState()
  AssertThrows call g:buffer.OpenDoRestore(function('Foo'))
  AssertThrew 'ERROR(BadValue)'
  call AssertSameState(g:state)

Execute (Buffer: OpenDoRestore Restores Everything on Bad Evaltext):
  let g:state = SaveState()
  AssertThrows call g:buffer.OpenDoRestore("throw 'BBBBB'")
  AssertThrew 'BBBBB'
  call AssertSameState(g:state)

" Since split moves the cursor to the new split, check relative position by
" moving *back* to the original window and checking that it *isn't* the owned
" buffer.
Execute (Buffer: Open Horizontal Split):
  buffer 1
  call g:buffer.split('', 'botright')
Then:
  wincmd k
  Assert !exists('b:test_var')

Execute (Buffer: Open Vertical Split):
  buffer 1
  call g:buffer.vsplit('', 'botright')
Then:
  wincmd h
  Assert !exists('b:test_var')

Execute (Buffer: Wipeout Buffer):
  let g:bufnr = g:buffer.bufnr()
  AssertEqual g:bufnr, g:buffer.SetBuffer(bufnr('%'), 'bwipeout')


Given (Ten Lines of Text):
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Get Single Line):
  AssertEqual ['first line'], g:buffer.GetLines(1)

Execute (Buffer: Get All Lines):
  let g:expected = [
      \ 'first line',
      \ 'second line',
      \ 'third line',
      \ 'fourth line',
      \ 'fifth line',
      \ 'sixth line',
      \ 'seventh line',
      \ 'eighth line',
      \ 'ninth line',
      \ 'tenth line',
      \ ]
  AssertEqual g:expected, g:buffer.GetLines(1, -1)

Execute (Buffer: Get Range of Lines):
  let g:expected = [
      \ 'fourth line',
      \ 'fifth line',
      \ 'sixth line',
      \ 'seventh line',
      \ ]
  AssertEqual g:expected, g:buffer.GetLines(4, 7)

Execute (Buffer: Delete Buffer Contents):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.DeleteLines(1, 5)
Expect:
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Delete Everything):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.DeleteLines(1, -1)
Expect:
  

Execute (Buffer: Replace Buffer Contents):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.ReplaceLines(1, 5, g:lines)
Expect:
  foo1
  foo2
  foo3
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Replace Single Line):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.ReplaceLines(1, 1, g:lines)
Expect:
  foo1
  foo2
  foo3
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Replace Last Lines, Purely Numerically):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.ReplaceLines(6, 10, g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  foo1
  foo2
  foo3

Execute (Buffer: Replace Everything, Explicit Numeral):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.ReplaceLines(1, 10, g:lines)
Expect:
  foo1
  foo2
  foo3

Execute (Buffer: Delete Everything, Explicit Numeral):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.DeleteLines(1, 10)
Expect:
  

Execute (Buffer: Prepend Lines):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(0, g:lines)
Expect:
  foo1
  foo2
  foo3
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Insert Lines Midway):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(2, g:lines)
Expect:
  first line
  second line
  foo1
  foo2
  foo3
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line

Execute (Buffer: Insert Lines At End):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines('$', g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
  foo1
  foo2
  foo3

Execute (Buffer: Insert Lines At End w/ Explicit Line Number):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(10, g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
  foo1
  foo2
  foo3

Execute (Buffer: Insert Lines At End w/ Explicit Line Number Past-the-End):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(11, g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
  foo1
  foo2
  foo3

Execute (Buffer: Insert Lines At End w/ Explicit Line Number Past-the-End):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(11, g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
  foo1
  foo2
  foo3

Execute (Buffer: Insert Lines At End w/ Negative Indexing):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(-1, g:lines)
Expect:
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
  foo1
  foo2
  foo3

Execute (Buffer: endline before startline):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = []
  AssertThrows call g:buffer.ReplaceLines(4, 2, g:lines)
  AssertThrew 'ERROR(BadValue)'

Execute (Buffer: endline before startline (both negative)):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = []
  AssertThrows call g:buffer.ReplaceLines(-4, -5, g:lines)
  AssertThrew 'ERROR(BadValue)'

Execute (Buffer: endline before (negative) startline):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = []
  AssertThrows call g:buffer.ReplaceLines(-8, 2, g:lines)
  AssertThrew 'ERROR(BadValue)'

Execute (Buffer: endline (negative) before startline):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = []
  AssertThrows call g:buffer.ReplaceLines(4, -8, g:lines)
  AssertThrew 'ERROR(BadValue)'

Execute (Buffer: Negative Values are Out of Range):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:lines = []
  AssertThrows call g:buffer.ReplaceLines(-12, -8, g:lines)
  AssertThrew 'ERROR(BadValue)'

Execute (Buffer: Make Buffer Nonmodifiable (Setup)):
  call g:buffer.setbufvar('&modifiable', 0)
Then:
  AssertEqual 0, g:buffer.getbufvar('&modifiable')

Execute (Buffer: Nonmodifiable, Delete Buffer Contents):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.setbufvar('&modifiable', 0)
  call g:buffer.DeleteLines(1, 5)
Expect:
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
Then:
  AssertEqual 0, g:buffer.getbufvar('&modifiable')

Execute (Buffer: Nonmodifiable, Delete Everything):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.setbufvar('&modifiable', 0)
  call g:buffer.DeleteLines(1, -1)
Expect:
  
Then:
  AssertEqual 0, g:buffer.getbufvar('&modifiable')

Execute (Buffer: Nonmodifiable, Replace Buffer Contents):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.setbufvar('&modifiable', 0)
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.ReplaceLines(1, 5, g:lines)
Expect:
  foo1
  foo2
  foo3
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
Then:
  AssertEqual 0, g:buffer.getbufvar('&modifiable')

Execute (Buffer: Nonmodifiable, Prepend Lines):
  call g:buffer.SetBuffer(bufnr('%'))
  call g:buffer.setbufvar('&modifiable', 0)
  let g:lines = [
    \ 'foo1',
    \ 'foo2',
    \ 'foo3',
  \ ]
  call g:buffer.InsertLines(0, g:lines)
Expect:
  foo1
  foo2
  foo3
  first line
  second line
  third line
  fourth line
  fifth line
  sixth line
  seventh line
  eighth line
  ninth line
  tenth line
Then:
  AssertEqual 0, g:buffer.getbufvar('&modifiable')

Given (Searchable Text):
  the quick brown fox
  jumps over the lazy
  dog

Execute (Buffer: Search Setup, Disable Lazyredraw, Wraparound):
  set nowrapscan
  " so that we can test that lazyredraw value is being restored properly
  set nolazyredraw

Execute (Buffer: Search from w/in Buffer):
  " the position of the cursor should not affect the search, the cursor
  " position should be restored afterward, total number of tabs shouldn't
  " change
  call g:buffer.SetBuffer(bufnr('%'))
  normal! 3G
  let g:num_tabs = tabpagenr('$')
  let g:curpos = getcurpos()

  AssertEqual 2, g:buffer.search('the')

  AssertEqual 0, &lazyredraw
  AssertEqual g:num_tabs, tabpagenr('$'), 'Failed to close new tabpage'
  AssertEqual g:curpos, getcurpos()

Execute (Buffer: Search from Another Buffer):
  call g:buffer.SetBuffer(bufnr('%'))
  tabnew
  let g:bufnr = bufnr('%')

  AssertEqual 2, g:buffer.search('the')

  AssertEqual 0, &lazyredraw
  " tabnew'd buffer should be open
  AssertEqual g:bufnr, bufnr('%')

Execute (Buffer: Search from Good Line Number):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 2, g:buffer.search('the', '', 2)
  AssertEqual 0, &lazyredraw

Execute (Buffer: Search from Bad Line Number):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:num_tabs = tabpagenr('$')
  let g:curpos = getcurpos()
  AssertThrows call g:buffer.search('the', '', -10)
  AssertThrew 'ERROR(BadValue)'
  AssertEqual 0, &lazyredraw
  AssertEqual g:num_tabs, tabpagenr('$'), 'Failed to close new tabpage'
  AssertEqual g:curpos, getcurpos()

Execute (Buffer: Search Unreachable with Stopline):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:curpos = getcurpos()
  AssertEqual 0, g:buffer.search('dog', '', 1, 1)
  AssertEqual 0, &lazyredraw

" explicitly calling g:buffer.search() from the command line doesn't
" always return to the old tabpage without an explicit :tabnext <TABNR> call
" **THIS TEST DOES NOT EXPOSE THAT BUGGY BEHAVIOR** but is included for
" thoroughness, and in case we can get the test working in the future
Do (Buffer: Return to Old Tab After Cmdline Search):
  :-tabnew\<cr>
  iI am the man who arranges the blocks that descend upon\<cr>
  me from up above, they come down and I spin them around\<esc>
  :call g:buffer.SetBuffer(bufnr('%'))\<cr>
  :tabclose\<cr>
  :let g:curpos = getcurpos()\<cr>
  :let g:result = g:buffer.search('the')\<cr>
Then:
  call g:buffer.CleanUp()
  AssertEqual 1, g:result
  AssertEqual g:curpos, getcurpos()

Execute (Buffer: Search with Wraparound):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 1, g:buffer.search('the', 'w', 3)
  AssertEqual 0, &lazyredraw

Execute (Buffer: Search without Wraparound):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 0, g:buffer.search('the', 'W', 3)
  AssertEqual 0, &lazyredraw

Execute (Buffer: Search from curpos w/out 'c'):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 2, g:buffer.search('the', '', [1, 1])
  AssertEqual 0, g:buffer.search('the', '', [2, 12])
  AssertEqual 0, &lazyredraw

Execute (Buffer: Search from curpos w/ 'c'):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 1, g:buffer.search('the', 'c', [1, 1])
  AssertEqual 0, &lazyredraw

  AssertEqual 2, g:buffer.search('the', 'c', [2, 12])
  AssertEqual 0, &lazyredraw

Execute (Buffer: Search w/ Bad Flags):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertThrows call g:buffer.search('the', 'D')
  AssertThrew 'ERROR(BadValue)'
  AssertEqual 0, &lazyredraw

  AssertThrows call g:buffer.search('the', 's')
  AssertThrows call g:buffer.search('the', 'cez')

Execute (Buffer: Search w/ Bad Flags, but Ignore Bad Flags):
  call g:buffer.SetBuffer(bufnr('%'))
  AssertEqual 2, g:buffer.search('the', 'D', 1, 0, 0, 1)

Execute (Buffer: Bad curpos, Wrong List Size):
  call g:buffer.SetBuffer(bufnr('%'))

  " empty
  AssertThrows call g:buffer.search('the', '', [])
  AssertThrew 'ERROR(BadValue)'

  " one elt
  AssertThrows call g:buffer.search('the', '', [2])
  AssertThrew 'ERROR(BadValue)'

  " three elts
  AssertThrows call g:buffer.search('the', '', [2, 1, 5])
  AssertThrew 'ERROR(BadValue)'

  " six elts
  AssertThrows call g:buffer.search('the', '', [2, 1, 5, 10, 10, 3])

Execute (Buffer: Is Open in this Tab, Yes):
  tabnew
  call g:buffer.SetBuffer(bufnr('%'))
Then:
  AssertEqual 1, g:buffer.IsOpenInTab()
  AssertEqual 1, g:buffer.IsOpenInTab(tabpagenr())

Execute (Buffer: Is Open in Previous Tab):
  call g:buffer.SetBuffer(bufnr('%'))
  let g:old_tab = tabpagenr()
  tabnew
Then:
  AssertEqual 1, g:buffer.IsOpenInTab(g:old_tab)
  AssertEqual 0, g:buffer.IsOpenInTab()
  AssertEqual 0, g:buffer.IsOpenInTab(tabpagenr())

Execute (Buffer: Is Open in Previous Tab, and In Current):
  call g:buffer.Open()
Then:
  AssertEqual 1, g:buffer.IsOpenInTab(g:old_tab)
  AssertEqual 1, g:buffer.IsOpenInTab()
  AssertEqual 1, g:buffer.IsOpenInTab(tabpagenr())

Execute (Buffer: Is Not Open At All):
  tabnew
  call g:buffer.SetBuffer(bufnr('%'))
  tabnew
  call g:buffer.CleanUp()
Then:
  AssertEqual 0, g:buffer.IsOpenInTab(g:old_tab)
  AssertEqual 0, g:buffer.IsOpenInTab()
  AssertEqual 0, g:buffer.IsOpenInTab(tabpagenr())

Execute (Buffer: Switch, Not Open):
  AssertThrows call g:buffer.Switch()
  AssertThrew 'ERROR(NotFound)'

Execute (Buffer: Switch, Is Open, Same Tab):
  call g:buffer.SetBuffer(bufnr('%'))
  tabnew
  let g:tabnr = tabpagenr()
  call g:buffer.Open()
  call g:buffer.Switch()
Then:
  AssertEqual g:tabnr, tabpagenr()
  AssertEqual g:buffer.bufnr(), bufnr('%')

Execute (Buffer: Switch, Is Open, Different Tab (but not allowed)):
  tabnew
  call g:buffer.SetBuffer(bufnr('%'))
  let g:tabnr = tabpagenr()
  tabnew
Then:
  AssertThrows call g:buffer.Switch(0)
  AssertThrew 'ERROR(NotFound)'

Execute (Buffer: Switch, Is Open, Different Tab (which is allowed)):
  call g:buffer.Switch()
Then:
  AssertEqual g:tabnr, tabpagenr()
  AssertEqual g:buffer.bufnr(), bufnr('%')

Execute (Buffer: Switch, Is Only Open in Different (Specific) Tab (which isn't allowed)):
  tabnew
Then:
  AssertThrows call g:buffer.Switch(0)
  AssertThrew 'ERROR(NotFound)'

Execute (Buffer: Switch, Is Only Open in Different (Specific) Tab (which is given)):
  tabnew
  call g:buffer.SetBuffer(bufnr('%'))
  let g:tabnr = tabpagenr()
  tabnew
  call g:buffer.Switch(0, g:tabnr)
Then:
  AssertEqual g:tabnr, tabpagenr()
  AssertEqual g:buffer.bufnr(), bufnr('%')

Execute (Buffer: Switch, Is Open in Different (Specific) Tab (which is given), and Current (not given)):
  tabnew
  call g:buffer.SetBuffer(bufnr('%'))
  let g:tabnr = tabpagenr()
  tabnew
  call g:buffer.Open()
  call g:buffer.Switch(0, g:tabnr)
Then:
  AssertEqual g:tabnr, tabpagenr()
  AssertEqual g:buffer.bufnr(), bufnr('%')
